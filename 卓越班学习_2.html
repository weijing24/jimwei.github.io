<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  卓越班学习 - 小菜鸡
  
  </title>
 <meta name="description" content="个人博客">
 <link href="atom.xml" rel="alternate" title="小菜鸡" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">小菜鸡</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 小菜鸡</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>容器</label></li>

          
            <li><a title="制作nginx和php的rpm包" href="15033225667618.html">制作nginx和php的rpm包</a></li>
          

      
        <li class="divider"></li>
        <li><label>web服务器</label></li>

          
            <li><a title="图解正向代理、反向代理、透明代理" href="15033223691311.html">图解正向代理、反向代理、透明代理</a></li>
          
            <li><a title="详解apache的allow和deny" href="15033200332645.html">详解apache的allow和deny</a></li>
          

      
        <li class="divider"></li>
        <li><label>卓越班学习</label></li>

          
            <li><a title="ELF和a.out文件格式的比较" href="15038328822812.html">ELF和a.out文件格式的比较</a></li>
          
            <li><a title="linux多线程编程入门" href="15038316827096.html">linux多线程编程入门</a></li>
          
            <li><a title="linux进程编程入门" href="15038316680304.html">linux进程编程入门</a></li>
          
            <li><a title="shell系统管理" href="15038311430982.html">shell系统管理</a></li>
          
            <li><a title="shell编程入门" href="15038311023811.html">shell编程入门</a></li>
          
            <li><a title="shell网络管理" href="15038310714574.html">shell网络管理</a></li>
          
            <li><a title="wait和waitpid详解" href="15033229130846.html">wait和waitpid详解</a></li>
          
            <li><a title="信号" href="15033227238921.html">信号</a></li>
          
            <li><a title="僵尸进程和孤儿进程" href="15033226512813.html">僵尸进程和孤儿进程</a></li>
          
            <li><a title="共享内存" href="15033226237472.html">共享内存</a></li>
          
            <li><a title="基于TCP的字符串传输程序" href="15033223148818.html">基于TCP的字符串传输程序</a></li>
          
            <li><a title="文件搜索" href="15033220404521.html">文件搜索</a></li>
          
            <li><a title="文件比较" href="15033218983068.html">文件比较</a></li>
          
            <li><a title="文件编辑" href="15033218793219.html">文件编辑</a></li>
          
            <li><a title="文件设置" href="15033218534320.html">文件设置</a></li>
          
            <li><a title="系统文件操作开发" href="15033218072587.html">系统文件操作开发</a></li>
          
            <li><a title="系统环境变量" href="15033217888989.html">系统环境变量</a></li>
          
            <li><a title="静态库和共享库开发" href="%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BC%80%E5%8F%91.html">静态库和共享库开发</a></li>
          

      
        <li class="divider"></li>
        <li><label>坑</label></li>

          
            <li><a title="<center>数据库非正常关闭导致无法启动问题</center>" href="15033220957416.html"><center>数据库非正常关闭导致无法启动问题</center></a></li>
          
            <li><a title="解决virtualbox安装增强工具失败的问题" href="15033217564988.html">解决virtualbox安装增强工具失败的问题</a></li>
          
            <li><a title="记一次ftp服务器搭建走过的坑" href="15033217230950.html">记一次ftp服务器搭建走过的坑</a></li>
          
            <li><a title="记一次mysql主从一致校验走过的坑" href="15033215794872.html">记一次mysql主从一致校验走过的坑</a></li>
          

      
        <li class="divider"></li>
        <li><label>日常运维</label></li>

          
            <li><a title="dns服务器报错解决" href="15038329582108.html">dns服务器报错解决</a></li>
          
            <li><a title="docker随谈" href="15038329005848.html">docker随谈</a></li>
          
            <li><a title="i节点，容易被人遗忘的节点" href="15038322315997.html">i节点，容易被人遗忘的节点</a></li>
          
            <li><a title="libc.so.6被删后导致系统无法使用的原因及解决方法" href="15038321032705.html">libc.so.6被删后导致系统无法使用的原因及解决方法</a></li>
          
            <li><a title="linux下nginx模块开发入门" href="15038318990451.html">linux下nginx模块开发入门</a></li>
          
            <li><a title="Linux下配置rsync服务器" href="15038318551859.html">Linux下配置rsync服务器</a></li>
          
            <li><a title="mysql初始化" href="15038316518471.html">mysql初始化</a></li>
          
            <li><a title="nagios安装" href="15038316187109.html">nagios安装</a></li>
          
            <li><a title="nagios配置" href="15038315676757.html">nagios配置</a></li>
          
            <li><a title="nginx、mysql、php等各编译参数查询" href="15038315492978.html">nginx、mysql、php等各编译参数查询</a></li>
          
            <li><a title="nginx性能优化技巧" href="15038314081873.html">nginx性能优化技巧</a></li>
          
            <li><a title="php安装memcache扩展" href="15038313472966.html">php安装memcache扩展</a></li>
          
            <li><a title="puppet和ansible比较" href="15038313193415.html">puppet和ansible比较</a></li>
          
            <li><a title="puppet学习笔记(二)" href="15038312823109.html">puppet学习笔记(二)</a></li>
          
            <li><a title="puppet学习笔记（一）" href="15038311899167.html">puppet学习笔记（一）</a></li>
          
            <li><a title="ssh大坑" href="15038309933322.html">ssh大坑</a></li>
          
            <li><a title="svn同步大坑" href="15038308908725.html">svn同步大坑</a></li>
          
            <li><a title="svn服务器搭建与迁移" href="15038308118838.html">svn服务器搭建与迁移</a></li>
          
            <li><a title="ubuntu mysql5.7源码安装" href="15033230940135.html">ubuntu mysql5.7源码安装</a></li>
          
            <li><a title="ubuntu php5.6源码安装" href="15033230316456.html">ubuntu php5.6源码安装</a></li>
          
            <li><a title="ubuntu下nginx的安裝" href="15033229668634.html">ubuntu下nginx的安裝</a></li>
          
            <li><a title="ubuntu安装php常见错误集锦" href="15033229497885.html">ubuntu安装php常见错误集锦</a></li>
          
            <li><a title="vim常用命令" href="15033229297218.html">vim常用命令</a></li>
          
            <li><a title="使用RAID进行磁盘管理" href="15033227857622.html">使用RAID进行磁盘管理</a></li>
          
            <li><a title="使用virt-manager创建和管理虚拟机" href="15033227559982.html">使用virt-manager创建和管理虚拟机</a></li>
          
            <li><a title="关于mysqld_safe" href="15033226078265.html">关于mysqld_safe</a></li>
          
            <li><a title="安装linux各种桌面环境" href="15033222846104.html">安装linux各种桌面环境</a></li>
          
            <li><a title="常用软件编译参数以及软件地址" href="15033222695994.html">常用软件编译参数以及软件地址</a></li>
          
            <li><a title="打造属于自己的vim利器" href="15033222443468.html">打造属于自己的vim利器</a></li>
          
            <li><a title="搭建本地yum源服务器" href="15033221654695.html">搭建本地yum源服务器</a></li>
          

      
        <li class="divider"></li>
        <li><label>http</label></li>

          
            <li><a title="HTTP协议 (七) Cookie" href="15038327056467.html">HTTP协议 (七) Cookie</a></li>
          
            <li><a title="HTTP协议 (六) 状态码详解" href="15038326831174.html">HTTP协议 (六) 状态码详解</a></li>
          
            <li><a title="HTTP协议 (五) 代理" href="15038326274764.html">HTTP协议 (五) 代理</a></li>
          
            <li><a title="HTTP协议 (四) 缓存" href="15038325535184.html">HTTP协议 (四) 缓存</a></li>
          
            <li><a title="HTTP协议 (三) 压缩" href="15038324866170.html">HTTP协议 (三) 压缩</a></li>
          
            <li><a title="HTTP协议 (二) 基本认证" href="15038324138209.html">HTTP协议 (二) 基本认证</a></li>
          
            <li><a title="HTTP协议 (一) HTTP协议详解" href="15038322654511.html">HTTP协议 (一) HTTP协议详解</a></li>
          

      
        <li class="divider"></li>
        <li><label>监控</label></li>

          
            <li><a title="zabbix安装排错过程" href="15033228802565.html">zabbix安装排错过程</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>容器</span></li>
                        
                          <li><a title="制作nginx和php的rpm包" href="15033225667618.html">制作nginx和php的rpm包</a></li>
                        

                    
                      <li class="side-title"><span>web服务器</span></li>
                        
                          <li><a title="图解正向代理、反向代理、透明代理" href="15033223691311.html">图解正向代理、反向代理、透明代理</a></li>
                        
                          <li><a title="详解apache的allow和deny" href="15033200332645.html">详解apache的allow和deny</a></li>
                        

                    
                      <li class="side-title"><span>卓越班学习</span></li>
                        
                          <li><a title="ELF和a.out文件格式的比较" href="15038328822812.html">ELF和a.out文件格式的比较</a></li>
                        
                          <li><a title="linux多线程编程入门" href="15038316827096.html">linux多线程编程入门</a></li>
                        
                          <li><a title="linux进程编程入门" href="15038316680304.html">linux进程编程入门</a></li>
                        
                          <li><a title="shell系统管理" href="15038311430982.html">shell系统管理</a></li>
                        
                          <li><a title="shell编程入门" href="15038311023811.html">shell编程入门</a></li>
                        
                          <li><a title="shell网络管理" href="15038310714574.html">shell网络管理</a></li>
                        
                          <li><a title="wait和waitpid详解" href="15033229130846.html">wait和waitpid详解</a></li>
                        
                          <li><a title="信号" href="15033227238921.html">信号</a></li>
                        
                          <li><a title="僵尸进程和孤儿进程" href="15033226512813.html">僵尸进程和孤儿进程</a></li>
                        
                          <li><a title="共享内存" href="15033226237472.html">共享内存</a></li>
                        
                          <li><a title="基于TCP的字符串传输程序" href="15033223148818.html">基于TCP的字符串传输程序</a></li>
                        
                          <li><a title="文件搜索" href="15033220404521.html">文件搜索</a></li>
                        
                          <li><a title="文件比较" href="15033218983068.html">文件比较</a></li>
                        
                          <li><a title="文件编辑" href="15033218793219.html">文件编辑</a></li>
                        
                          <li><a title="文件设置" href="15033218534320.html">文件设置</a></li>
                        
                          <li><a title="系统文件操作开发" href="15033218072587.html">系统文件操作开发</a></li>
                        
                          <li><a title="系统环境变量" href="15033217888989.html">系统环境变量</a></li>
                        
                          <li><a title="静态库和共享库开发" href="%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BC%80%E5%8F%91.html">静态库和共享库开发</a></li>
                        

                    
                      <li class="side-title"><span>坑</span></li>
                        
                          <li><a title="<center>数据库非正常关闭导致无法启动问题</center>" href="15033220957416.html"><center>数据库非正常关闭导致无法启动问题</center></a></li>
                        
                          <li><a title="解决virtualbox安装增强工具失败的问题" href="15033217564988.html">解决virtualbox安装增强工具失败的问题</a></li>
                        
                          <li><a title="记一次ftp服务器搭建走过的坑" href="15033217230950.html">记一次ftp服务器搭建走过的坑</a></li>
                        
                          <li><a title="记一次mysql主从一致校验走过的坑" href="15033215794872.html">记一次mysql主从一致校验走过的坑</a></li>
                        

                    
                      <li class="side-title"><span>日常运维</span></li>
                        
                          <li><a title="dns服务器报错解决" href="15038329582108.html">dns服务器报错解决</a></li>
                        
                          <li><a title="docker随谈" href="15038329005848.html">docker随谈</a></li>
                        
                          <li><a title="i节点，容易被人遗忘的节点" href="15038322315997.html">i节点，容易被人遗忘的节点</a></li>
                        
                          <li><a title="libc.so.6被删后导致系统无法使用的原因及解决方法" href="15038321032705.html">libc.so.6被删后导致系统无法使用的原因及解决方法</a></li>
                        
                          <li><a title="linux下nginx模块开发入门" href="15038318990451.html">linux下nginx模块开发入门</a></li>
                        
                          <li><a title="Linux下配置rsync服务器" href="15038318551859.html">Linux下配置rsync服务器</a></li>
                        
                          <li><a title="mysql初始化" href="15038316518471.html">mysql初始化</a></li>
                        
                          <li><a title="nagios安装" href="15038316187109.html">nagios安装</a></li>
                        
                          <li><a title="nagios配置" href="15038315676757.html">nagios配置</a></li>
                        
                          <li><a title="nginx、mysql、php等各编译参数查询" href="15038315492978.html">nginx、mysql、php等各编译参数查询</a></li>
                        
                          <li><a title="nginx性能优化技巧" href="15038314081873.html">nginx性能优化技巧</a></li>
                        
                          <li><a title="php安装memcache扩展" href="15038313472966.html">php安装memcache扩展</a></li>
                        
                          <li><a title="puppet和ansible比较" href="15038313193415.html">puppet和ansible比较</a></li>
                        
                          <li><a title="puppet学习笔记(二)" href="15038312823109.html">puppet学习笔记(二)</a></li>
                        
                          <li><a title="puppet学习笔记（一）" href="15038311899167.html">puppet学习笔记（一）</a></li>
                        
                          <li><a title="ssh大坑" href="15038309933322.html">ssh大坑</a></li>
                        
                          <li><a title="svn同步大坑" href="15038308908725.html">svn同步大坑</a></li>
                        
                          <li><a title="svn服务器搭建与迁移" href="15038308118838.html">svn服务器搭建与迁移</a></li>
                        
                          <li><a title="ubuntu mysql5.7源码安装" href="15033230940135.html">ubuntu mysql5.7源码安装</a></li>
                        
                          <li><a title="ubuntu php5.6源码安装" href="15033230316456.html">ubuntu php5.6源码安装</a></li>
                        
                          <li><a title="ubuntu下nginx的安裝" href="15033229668634.html">ubuntu下nginx的安裝</a></li>
                        
                          <li><a title="ubuntu安装php常见错误集锦" href="15033229497885.html">ubuntu安装php常见错误集锦</a></li>
                        
                          <li><a title="vim常用命令" href="15033229297218.html">vim常用命令</a></li>
                        
                          <li><a title="使用RAID进行磁盘管理" href="15033227857622.html">使用RAID进行磁盘管理</a></li>
                        
                          <li><a title="使用virt-manager创建和管理虚拟机" href="15033227559982.html">使用virt-manager创建和管理虚拟机</a></li>
                        
                          <li><a title="关于mysqld_safe" href="15033226078265.html">关于mysqld_safe</a></li>
                        
                          <li><a title="安装linux各种桌面环境" href="15033222846104.html">安装linux各种桌面环境</a></li>
                        
                          <li><a title="常用软件编译参数以及软件地址" href="15033222695994.html">常用软件编译参数以及软件地址</a></li>
                        
                          <li><a title="打造属于自己的vim利器" href="15033222443468.html">打造属于自己的vim利器</a></li>
                        
                          <li><a title="搭建本地yum源服务器" href="15033221654695.html">搭建本地yum源服务器</a></li>
                        

                    
                      <li class="side-title"><span>http</span></li>
                        
                          <li><a title="HTTP协议 (七) Cookie" href="15038327056467.html">HTTP协议 (七) Cookie</a></li>
                        
                          <li><a title="HTTP协议 (六) 状态码详解" href="15038326831174.html">HTTP协议 (六) 状态码详解</a></li>
                        
                          <li><a title="HTTP协议 (五) 代理" href="15038326274764.html">HTTP协议 (五) 代理</a></li>
                        
                          <li><a title="HTTP协议 (四) 缓存" href="15038325535184.html">HTTP协议 (四) 缓存</a></li>
                        
                          <li><a title="HTTP协议 (三) 压缩" href="15038324866170.html">HTTP协议 (三) 压缩</a></li>
                        
                          <li><a title="HTTP协议 (二) 基本认证" href="15038324138209.html">HTTP协议 (二) 基本认证</a></li>
                        
                          <li><a title="HTTP协议 (一) HTTP协议详解" href="15038322654511.html">HTTP协议 (一) HTTP协议详解</a></li>
                        

                    
                      <li class="side-title"><span>监控</span></li>
                        
                          <li><a title="zabbix安装排错过程" href="15033228802565.html">zabbix安装排错过程</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>基于TCP的字符串传输程序</h1>

		<p>Linux中的网络编程是通过SOCKET接口来进行的。<br/>
Socket（套接字）<br/>
　Socket相当于进行网络通信两端的插座，只要对方的Socket和自己的Socket有通信联接，双方就可以发送和接收数据了。Socket的定义类似于文件句柄的定义。下面的流程图大概描述了基于TCP协议的网络编程过程。同学们只需要对大概流程有一个初步认识即可，暂时不必深究每个函数的意义。因为在后面的实训子任务中，每一个函数的具体内容和使用方法都会讲到。<br/>
　　　TCP协议socket流程图<br/>
<img src="media/15033223148818/15033223274146.jpg" alt=""/><br/>
基本套接字调用顺序如下：</p>

<p><strong>创建套接字--socket()--&gt;绑定本机端口--bind();--&gt;建立连接--connect(),accept();--&gt;侦听端口--listen();--&gt;数据传输--send(),recv();--&gt;输入/输出多路复用--select();--&gt;关闭套接字--closesocket();</strong> <br/>
其中，服务器端基于TCP的编程步骤大致如下：<br/>
① 创建套接字；<br/>
　　建立服务器端的socket套接字：int socket(int domain，int type，int protocol)<br/>
②绑定套接字到一个IP地址和一个端口上<br/>
 　　int bind(int sockfd,struct sockaddr * myaddr,int addrlen)；<br/>
③将套接字设置为监听模式，以等待连接请求<br/>
　　int listen(int sockfd，int backlog)<br/>
④请求到来后，接受连接请求，并返回一个与此次连接对应的套接字<br/>
　　int accept(int sockfd，struct sockaddr * addr，int * addrlen)<br/>
　　此时新建连接，并创建新的Socket套接字，此时addr为客户端的addr信息。<br/>
⑤用返回的套接字和客户端进行通信<br/>
　　使用recv()和send()<br/>
⑥关闭服务器端的套接字描述符<br/>
　　int close(int sockfd)；</p>

<p>客户端调用顺序如下：<br/>
①创建客户端套接字<br/>
　　int socket(int domain，int type，int protocol)<br/>
②向服务器发出连接请求<br/>
　　int connect（int sockfd，struct sockaddr * servaddr，int addrlen）<br/>
　　其中参数servaddr指定远程服务器的套接字地址，包括服务器的IP地址和端口号<br/>
③和服务器端进行网络通信<br/>
　　使用recv()和send()<br/>
　　int read(int fd，char * buf，int len)<br/>
　　int write(int fd，char * buf，int len)<br/>
④关闭套接字<br/>
　　int close(int sockfd)；</p>

<h4 id="toc_0">1.网络字节序和本地字节序相互转换</h4>

<p>任务要求：</p>

<ul>
<li>打印本地字节序</li>
<li>用htonl函数把本地字节序转换成网络字节序，并打印</li>
</ul>

<p>相关知识：</p>

<ul>
<li>小端法(Little-Endian)就是低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端。</li>
<li>大端法(Big-Endian)就是高位字节排放在内存的低地址端即该值的起始地址，低位字节排放在内存的高地址端。</li>
</ul>

<p>　　举个简单的例子，对于整形0x12345678。它在大端法和小端法的系统内中，分别如图1所示的方式存放。<br/>
<img src="media/15033223148818/15033223361762.jpg" alt=""/></p>

<ul>
<li>网络字节序　</li>
</ul>

<p>　　我们知道网络上的数据流是字节流，对于一个多字节数值，在进行网络传输的时候，先传递哪个字节？也就是说，当接收端收到第一个字节的时候，它是将这个字节作为高位还是低位来处理呢？ <br/>
　　<strong>网络字节序定义：收到的第一个字节被当作高位看待，这就要求发送端发送的第一个字节应当是高位。而在发送端发送数据时，发送的第一个字节是该数字在内存中起始地址对应的字节。可见多字节数值在发送前，在内存中数值应该以大端法存放。</strong> <br/>
　　uint32_t htonl(uint32_t hostlong)：<strong>htonl 表示 host to network long ，用于将主机 　　unsigned int 型数据转换成网络字节顺序；</strong><br/><br/>
　　uint16_t htons(uint16_t hostshort)：htons 表示 host to network short ，用于将主机 unsigned short 型数据转换成网络字节顺序；<br/>
　　ntohl、ntohs 的功能分别与 htonl、htons 相反。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;arpa/inet.h&quot;
//网络字节序和本地字节序相互转换
int main(void){
    int num=0x12345678,i;
    printf(&quot;before convert :%x\n&quot;,num);
    for(i=0;i&lt;4;i++)
        printf(&quot;[%d]:0x%x\n&quot;,i,*((char *)&amp;num+i));//将num转化成char型指针，+i表示向后偏移8位,16进制是4个4位，那么8位对应了2个字符。
    num=htonl(num);
    printf(&quot;after convert :%x\n&quot;,num);
    for(i=0;i&lt;4;i++)
        printf(&quot;[%d]:0x%x\n&quot;,i,*((char *)&amp;num+i));
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_1">2.利用socket函数创建一个网络套接字</h4>

<p>任务描述：</p>

<ul>
<li>c语言编写服务端程序，利用socket函数创建一个套接字（TCP协议）</li>
<li>返回函数套接字状态，若成功，打印创建成功信息，失败，返回失败原因</li>
</ul>

<p>相关知识：</p>

<ul>
<li>socket相当于进行网络通信两端的插座，只要对方的Socket和自己的Socket有通信联接，双方就可以发送和接收数据了。Socket的定义类似于文件句柄的定义。</li>
</ul>

<p>　　int socket(int family, int type, int protocol );<br/>
　　<strong>为了在网络上进行I/O通信，第一件事就是要调用socket函数，创建套接字，并指定相应的通信协议类型。第一个参数family一般设置为AF_INET，对于IPv6网络，则需设置成AF_INET6。对于Unix域协议套接字，该参数的值是AF_LOCAL，对于路由套接字，该参数的值是AF_ROUTE，对于秘钥套接字，该参数的值是AF_KEY。第二个参数type制定了套接字接口的类型，其值分别为SOCK_STREAM或SOCK_DGRAM。这两个参数分别表示该套接字是TCP协议类型或者是UDP协议类型。该参数还有两个选项,分别为SOCK_SEQPACKET和SOCK_RAW，前一个表示有序分组的套接字，后一个表示原始套接字。第三个参数一般设置为0。</strong><br/>
　　socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它们称之为套接字描述符，简称sockfd。为了得到这个套接字描述符，我们只是制定了协议族(IPv4、IPv6或Unix)和套接字类型(字节流、数据报或原始套接字)。我们并没有指定本地协议地址或者远程协议地址。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
int  main(void){
    int sockfd;
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;create socket fail\n&quot;);
        exit(1);
    }else
        printf(&quot;create success\n&quot;);       
    close(sockfd);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_2">3.利用bind函数将创建好的套接字绑定到本地计算机的某一端口上</h4>

<p>任务描述：</p>

<ul>
<li>调用bind函数，并将创建好的套接字绑定到指定端口上，如2500端口 </li>
</ul>

<p>相关知识：<br/>
　　对于服务器端来说，一旦通过socket函数创建了套接字以后，下一步就需要把该套接字绑定到本地计算机的某一个端口上。bind函数的作用就是完成该功能。<br/>
　　int bind(int sockfd, const struct sockaddr* myaddr, socklen_t addrlen);<br/>
　　第一个参数sockfd是由socket()调用返回的套接口文件描述符。第二个参数myaddr是指向数据结构sockaddr的指针。<strong>数据结构sockaddr中包括了关于服务器的地址、端口和IP地址的信息。</strong>第三个参数addrlen表示sockaddr结构体的长度，可以设置成sizeof(struct sockaddr)。bind函数可以指定一个端口号，或者指定一个IP地址，也可以两者都指定或者都不指定。如果指定端口号为0，那么内核就在bind被调用的时候选择一个临时接口。如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回选择的端口号值。因为bind函数的第二个参数是const类型的，它无法返回内核所分配的端口号。为了得到内核默认分配的端口号，必须调用函数getsockname函数来获取。值得一提的是，当不指定本地IP地址时，系统会为该socket分配一个默认IP地址。分配方式：myaddr.sin_addr.s_addr = htonl(INADDR_ANY)；其中INADDR_ANY表示IPv4的通配地址。这个值一般为0，在这种选择下，内核将等到套接字已经连接（TCP）或者在套接字上发出数据报（UDP）时，才会选择一个本地IP地址。当server有多个网卡时，可以指定绑定到特定的网卡IP上，分配方式：myaddr.sin_addr.s_addr=inet_addr(&quot;192.168.0.123&quot;)；绑定到服务器特定端口的指定方式为：myaddr.sin_port=htons(12345);</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;netinet/in.h&quot;
#include &quot;string.h&quot;
//利用bind函数将创建好的套接字绑定到本地计算机的某一端口上
int main(void){
    int sockfd,bind_fd;
    struct sockaddr_in servaddr;
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;create socket fail\n&quot;);
        exit(1);
    }else    
        printf(&quot;create success\n&quot;);
    //初始化
    bzero(&amp;servaddr,sizeof(servaddr));//结构体初始化
    servaddr.sin_family=AF_INET;//确定ip协议
    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);//接收任意ip
    servaddr.sin_port=htons(2500);//设定端口号2500
    //绑定端口
    bind_fd=bind(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));
    if(bind_fd==-1){
        perror(&quot;bind fail\n&quot;);
        exit(1);
    }else       
        printf(&quot;bind success\n&quot;);       
    close(sockfd);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_3">4.利用listen函数将已经绑定的套接字设置为被动连接监听状态</h4>

<p>任务描述：</p>

<ul>
<li>在task3中创建好并绑定到本地特定端口的套接字上，增加listen函数，使得套接字处于监听状态</li>
<li>打印监听函数调用成功与否</li>
</ul>

<p>相关知识：</p>

<p>　　listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。<br/>
　　int listen(int sockfd, int backlog)<br/>
　　参数sockfd被listen函数作用的套接字，sockfd之前由socket函数返回。在被socket函数返回的套接字fd之时，它是一个主动连接的套接字，也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，用户进程通过系统调用listen来完成这件事。<br/>
　　参数backlog这个参数涉及到一些网络的细节。在进程正理一个一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。如果这个情况出现了，服务器进程希望内核如何处理呢？内核会在自己的进程空间里维护一个队列以跟踪这些完成的连接但服务器进程还没有接手处理或正在进行的连接，这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限。这个backlog告诉内核使用这个数值作为上限。毫无疑问，服务器进程不能随便指定一个数值，内核有一个许可的范围。这个范围是实现相关的。很难有某种统一，<strong>一般这个值会小30以内。</strong><br/>
　　当调用listen之后，服务器进程就可以调用accept来接受一个外来的请求。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;netinet/in.h&quot;
#include &quot;string.h&quot;
//利用listen函数将已经绑定的套接字设置为被动连接监听状态
int main(void){
    int sockfd,bind_fd,listen_fd;
    struct sockaddr_in servaddr;
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;create socket fail\n&quot;);
        exit(1);
    }else       
        printf(&quot;create success\n&quot;);       
</code></pre>
</blockquote>

<pre><code>    //初始化
    bzero(&amp;servaddr,sizeof(servaddr));//结构体初始化
    servaddr.sin_family=AF_INET;//确定ip协议
    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);//接收任意ip
    servaddr.sin_port=htons(2500);//设定端口号2500
    //绑定端口
    bind_fd=bind(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));
    if(bind_fd==-1){
        perror(&quot;bind fail\n&quot;);
        exit(1);
    }else
        printf(&quot;bind success\n&quot;);
    //将已绑定的套接口设为被动连接监听
    listen_fd=listen(sockfd,10);
    if(listen_fd==-1){
        perror(&quot;listen fail\n&quot;);
        exit(1);
    }else       
        printf(&quot;listen success\n&quot;);
    close(sockfd);
    return 0;
}
</code></pre>

<h4 id="toc_4">5.利用accept函数来处理客户端请求的连接</h4>

<p>任务描述：</p>

<ul>
<li>在task4的程序中，添加对客户端连接的处理，调用accept函数，为客户端连接分配一个新的socket，并打印客户端IP地址和端口号</li>
</ul>

<p>相关知识：</p>

<ul>
<li>对于服务器编程中最重要的一步等待并接受客户的连接，那么这一步在编程中如何完成，accept函数就是完成这一步的。它从内核中取出已经建立的客户连接，然后把这个已经建立的连接返回给用户程序，此时用户程序就可以与自己的客户进行点到点的通信了。</li>
<li>int accept(int sockfd, struct sockaddr* addr, socklen_t* len)</li>
</ul>

<p>　　accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。此时我们需要区分两种套接字，一种套接字正如accept的参数sockfd，它是监听套接字，在调用listen函数之后，一个套接字会从主动连接的套接字变身为一个监听套接字；而accept返回是一个连接套接字，它代表着一个网络已经存在的点点连接。自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。<br/>
　　参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。<br/>
　　参数addr是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。<br/>
　　参数len也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;netinet/in.h&quot;
#include &quot;string.h&quot;
#include &quot;arpa/inet.h&quot;
#define MYPORT 3490
//利用accept函数来处理客户端请求的连接
int main(void){
    int sockfd,newfd,i,n;
    char buf[100];
    socklen_t len;
    struct sockaddr_in servaddr;
    struct sockaddr_in clientaddr;
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;socket error\n&quot;);
        exit(1);
    }else
        printf(&quot;create socket successful\n&quot;);       
    servaddr.sin_family=AF_INET;
    servaddr.sin_port=htons(MYPORT);
    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);
    bzero(&amp;(servaddr.sin_zero),8);
    n=bind(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));
    if(n==-1){
        perror(&quot;bind error\n&quot;);
        exit(1);
    }else
        printf(&quot;bind successful\n&quot;);
    i=listen(sockfd,10);
    if(i==-1){
        perror(&quot;listen error\n&quot;);
        exit(1);
    }else
        printf(&quot;listen successful\n&quot;);
    while(1){
        len=sizeof(clientaddr); 
        newfd=accept(sockfd,(struct sockaddr*)&amp;clientaddr,&amp;len);
        if(newfd==-1){
            perror(&quot;accept error\n&quot;);
            exit(1);
        }else
            printf(&quot;accept successful\n&quot;);       
        if(inet_ntop(AF_INET,&amp;clientaddr.sin_addr,buf,sizeof(buf))==NULL){//转化为本地可识别ip
            perror(&quot;inet_ntop error\n&quot;);
            exit(1);
        }
        printf(&quot;conneting from %s ,&quot;,buf);
        printf(&quot;port is %d\n&quot;,ntohs(clientaddr.sin_port));
        close(newfd);    
    }
    close(sockfd);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_5">6.利用connect函数创建客户端程序，连接前文编好的服务器程序</h4>

<p>任务描述：</p>

<ul>
<li>创建一个客户端，利用命令行模式输入IP地址，客户端程序调用connect函数与服务端取得连接。</li>
<li>argv[1]参数为目的IP地址，要求必须对连接不可达的各种状态进行解析，并打印提示信息</li>
<li>调用格式：./client IP地址。</li>
</ul>

<p>　　eg:./client 10.42.0.250（不可达IP）。提示：can not connect to 10.42.0.250,exit!<br/>
　　No route to host<br/>
　　./client 10.42.0.123（一个没开启server端服务的IP地址）。提示：can not connect to ×××,exit!<br/>
　　Connection refused<br/>
　　调用成功：./client 10.42.0.1.提示：connect to 10.42.0.1 successfully</p>

<p>相关知识：<br/>
　　与Server端程序不同的是，在Client端，创建了一个新的套接字之后，不需要调用bind函数进行与本地的绑定，只需要预先初始化好服务器端连接信息，也就是sockaddr_in server_addr即可。该结构体中必须包含网络协议的网络类型（对于IPv4，就是AF_INET），目的服务器的IP地址，目的服务器的端口号。<br/>
　　int connect(int sockfd, struct sockaddr *serv_addr, int addrlen)：参数sockfd 的套接字连至参数serv_addr 指定的网络地址<br/>
　　sockfd 是系统调用 socket() 返回的套接口文件描述符 ;serv_addr 是保存着目的地端口和 IP 地址的数据结构 struct sockaddr ;addrlen 设置为 sizeof(struct sockaddr) ;connect 激发 TCP的三路握手过程 </p>

<ul>
<li>这通过调用socket,bind和1isten函数来完成，称为被动打开(Passive open) </li>
<li>三次握手</li>
</ul>

<p>　　客户通过调用connect进行主动打开(active opn)。 这引起客户TCP发送一个SYN分节(表示同步)，它告诉服务器客户将在(待建立的)连接中发送的数据的初始序列号。服务器必须确认客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的韧始序列号。服务器以单个分节向客户发送SYN和对客户 SYN的ACK。客户必须确认服务器的SYN。 </p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;netinet/in.h&quot;
#include &quot;string.h&quot;
#include &quot;arpa/inet.h&quot;
#include &quot;errno.h&quot;
#define SERVER_PORT 3490
//利用connect函数创建客户端程序，连接前文编好的服务器程序
int main(int argc,char *argv[]){
    int sockfd,i,n;
    socklen_t len;
    struct sockaddr_in servaddr; 
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;socket error\n&quot;);
        exit(1);
    }else
        printf(&quot;create successful\n&quot;);
    len=sizeof(servaddr);
    bzero(&amp;servaddr,sizeof(servaddr));
    servaddr.sin_family=AF_INET;
    servaddr.sin_port=htons(SERVER_PORT);
    n=inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr);//转化为网络可识别的ip
    if(n==-1){
        printf(&quot;%s\n&quot;,strerror(errno));
        exit(1);
    }
    if(n==0){
        printf(&quot;ip error\n&quot;);
        exit(1);
    }
    i=connect(sockfd,(struct sockaddr*)&amp;servaddr,len);
    if(i&lt;0){
        printf(&quot;can&#39;t connect to %s,exit\n&quot;,argv[1]);
        printf(&quot;%s\n&quot;,strerror(errno));
        exit(1);
    }
    close(sockfd);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_6">7.获取套接字的地址族</h4>

<p>任务描述：</p>

<ul>
<li>c语言创建一个套接字，调用bind函数，其中端口设置为0，将被套接字绑定到本地某个端口上。</li>
<li>调用getsockname，显示内核为该bind函数分配的端口号</li>
</ul>

<p>相关知识：</p>

<ul>
<li>int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen)</li>
<li>int getpeername(int sockfd, struct sockaddr * peeraddr, socken_t * addrlen);　　　　　</li>
</ul>

<p>　　<strong>getsockname函数返回与套接口关联的本地协议地址。</strong>使用场合：在不调用bind的TCP客户，当connect成功返回后，getsockname返回分配给此连接的本地IP地址和本地端口号；<br/>
　　在以端口号为0调用bind后，使用getsockname返回内核分配的本地端口号；getsockname可用来获取某套接口的地址族；在捆绑了通配IP地址的TCP服务器上，当连接建立后，可以使用getsockname获得分配给此连接的本地IP地址；<br/>
　　getpeername返回远程协议地址描述结构。当一个服务器是由调用过accept的，并且fork出一个子进程进行业务逻辑处理时，必须调用getpeername来获取对端地址和端口号。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/socket.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;netinet/in.h&quot;
#include &quot;string.h&quot;
int main(void){
    int sockfd,bind_fd,listen_fd,newfd,n;
    char buf[100];
    struct sockaddr_in servaddr;
    socklen_t len=sizeof(servaddr);
    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd==-1){
        perror(&quot;create socket fail\n&quot;);
        exit(1);
    }else
        printf(&quot;create success\n&quot;);
    //初始化
    bzero(&amp;servaddr,sizeof(servaddr));//结构体初始化
    servaddr.sin_family=AF_INET;//确定ip协议
    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);//接收任意ip
    servaddr.sin_port=htons(0);//设定端口号2500
    //绑定端口
    bind_fd=bind(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));
    if(bind_fd==-1){
        perror(&quot;bind fail\n&quot;);
        exit(1);
    }else
        printf(&quot;bind success\n&quot;);
    listen_fd=listen(sockfd,10);
    if(listen_fd==-1){
        perror(&quot;listen fail\n&quot;);
        exit(1);
    }else
        printf(&quot;listen success\n&quot;);
    if(getsockname(sockfd,(struct sockaddr*)&amp;servaddr,&amp;len)==-1){
        perror(&quot;getsockname error\n&quot;);
        exit(1);
    }
    n=inet_ntop(AF_INET,&amp;servaddr,buf,sizeof(buf));
    printf(&quot;port :%d\n&quot;,ntohs(servaddr.sin_port));
    close(sockfd);
    return 0;
}
</code></pre>
</blockquote>


		</div>
	

 
	

 
	

 
	

 
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  </body>
</html>
