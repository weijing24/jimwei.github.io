<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[小菜鸡]]></title>
  <link href="weijing24.github.io/atom.xml" rel="self"/>
  <link href="weijing24.github.io/"/>
  <updated>2017-08-22T09:47:49+08:00</updated>
  <id>weijing24.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[dns服务器报错解决]]></title>
    <link href="weijing24.github.io/15038329582108.html"/>
    <updated>2017-08-27T19:22:38+08:00</updated>
    <id>weijing24.github.io/15038329582108.html</id>
    <content type="html"><![CDATA[
<p>搭了个dns服务器，配置完毕老是报错，这里总结一下常见思路：<br/>
　　①关闭firewalld<br/>
　　②关闭selinux<br/>
　　③/var/named里面的配置文件所属用户组是否是root：named<br/>
　　④named.conf写的zone文件名是否和/var/named中的文件名对应（不对应会报server can‘t find *** 解析错误）<br/>
　　⑤named.conf写了正（反）向解析在/var/named中就要有正（反）向解析文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker随谈]]></title>
    <link href="weijing24.github.io/15038329005848.html"/>
    <updated>2017-08-27T19:21:40+08:00</updated>
    <id>weijing24.github.io/15038329005848.html</id>
    <content type="html"><![CDATA[
<p>　　最近在搞Docker，其实去年就听老师说过这个东西，说非常火，当时不以为然，还错把它当成docky。当时想想docky不就是一个快速启动工具么，有什么。现在想想真是惭愧。。。</p>

<p>　　Docker的牛逼之处网上找找也有一大堆：轻量化、占用系统资源少（基本不占用）、部署快、扩展性强，可以说是虚拟化的未来。</p>

<p>　　Docker直接作用在宿主机上，不需要虚拟机管理系统。下图摘自网上：<br/>
<img src="media/15038329005848/15038329169605.jpg" alt=""/><br/>
　　可以看出使用Docker比一般的虚拟机少了两层东西，可见Docker的轻量。<br/>
　　Docker诞生之初也是为了能让开发者更专心的做开发，系统管理员更专注于系统的构架。所以Docker可以一次打包，在任何地方运行。它的官网也是这么说的：Build, Ship and Run Any App, Anywhere！试想一下当迁移服务器的时候你可能需要先将数据和应用迁出再部署到其他的服务器上，非常麻烦不说还有可能在这个过程中丢失数据。使用docker就没有这么多问题，你只需要将Docker image先上传到Docker Hub中然后在新的服务器中pull下来即可，是不是感觉这个过程和Git类似？Docker就是运用了集装箱的原理，它不在乎你是什么系统什么架构，它只负责把你关心的打包，然后交付给别人使用。<br/>
　　Docker有三个核心概念：容器、镜像、仓库。这三个如果铺开来讲恐怕这能成一个系列了，既然是随笔就力求用最短的话把它说清楚讲明白<br/>
　　镜像：镜像这个东西计算机专业的应该都能懂，它和我们装系统的镜像是一个东西。开发者把写好的程序打包放入镜像中就可以交付给别人使用（在这里可以不用纠结于这个镜像的具体内容），一般都是先从Docker Hub中下载一个现成的镜像然后开始开发自己要开发的东西。<br/>
　　容器：容器的概念比较绕，一开始我以为镜像是运行在容器中的，因为字面意思来看容器是容纳东西的嘛，但是事实是容器运行在镜像之上。我们知道镜像是不会改动的，当我们运行一个镜像那么他就生成了一个容器。可以把镜像想象成是一个程序，容器就是一个进程。镜像（程序）是静态的，容器（进程）是动态的。我们的开发部署工作都是在容器中<br/>
　　仓库：仓库就是存放镜像的地方。你可以建自己的私有仓库也可以建共有仓库。push可以把本地的镜像上传到Hub中，pull可以把Hub中的镜像下载到本地。把它想象成Github可以容易理解的多（暂时不要想版本控制，就单纯的上传和下载）。<br/>
　　这里必须要提Docker很牛的一个地方，就是容器的灵活性。镜像本身是由很多层文件系统组成的，当我们运行一个镜像产生了一个容器就会在镜像上添加一层<strong>读写层（位于下图的Container和Image之间的一层）！</strong>我们在容器中的所有操作都是作用在读写层上不会写入到镜像中。如果多次运行同一个镜像就会产生多个不同的容器（在镜像上平行的添加的读写层）。在这里可能会有疑问开这么多容器不就搞混了吗？容器是可以自己取名的，所以这完全不是问题。当你在容器内开发完程序就可以把容器打包为一个新的镜像，把没用的容器全部删掉。把你开发的具有稳定版程序的容器保留，下次开发使用start就能瞬间启动容器。<br/>
<img src="media/15038329005848/15038329277919.jpg" alt=""/><br/>
　　同时还有一个很重要的地方就是：<strong>Docker不是容器，而是管理容器的引擎。</strong>很多地方都会把Docker和容器划上等号，这是十分误导人的。</p>

<h3 id="toc_0">关于Docker安全性问题的思考</h3>

<p>　　Docker目前在安全性和稳定性上面还有待时间的检验。不过Docker在未正式发布时就有好几家金融机构开始使用了，要知道金融公司对于平台的稳定性和安全性要求是十分之高的，由此可见Docker的魅力。然而Docker在实际生产中还是有一些安全性问题的。<br/>
　　①由于Docker的仓库是开放的，任何人都可以下载使用，难保不会有人在<strong>镜像中植入后门。</strong><br/>
　　②尽管Docker有Namespace这层保障，但是由于<strong>Docker依赖于宿主机内核调度</strong>的先天特性，一旦内核出现Bug可以通过宿主机入侵容器，窃取生产环境信息。<br/>
　　③严格来说Docker不是虚拟机，普通虚拟机的root和宿主机的root是分开的，而Docker容器的root和宿主机的root是同一个用户，一旦<strong>容器内的用户提权至root，他就有了无限制的操作，要知道Docker容器是可以和宿主机共享文件系统的，容器内的用户提权了宿主机等于被提权了。</strong>Docker的本质是进程隔离，为进程创建隔离开的运行空间，这样就可以隔离有问题的应用。<strong>进程间的隔离是通过Namespace（作用：隔离）和Cgroup（作用：配额限制），隔离出来的进程组对外表现就是一个Container。</strong></p>

<h3 id="toc_1">新手使用Docker会遇到的坑</h3>

<p>　　此坑仅适用于中国程序员。感谢GFW，下载Docker并不是那么的简单，Ubuntu和Centos源中有Docker安装包，但是想要下载最新版或特定版本的并不是那么容易，因为Docker的网站在中国访问极慢，个人不是很推荐网上找不明来源的安装包下载安装，毕竟官方的才是最好的。这些问题都不是很大，最大的问题是下载和上传Docker镜像，<a href="https://hub.docker.com">https://hub.docker.com</a> 这个网站就跟段誉的武功一样时灵时不灵的（大多数时候不灵，能访问也是小水管），下面我分别给出下载Docker和镜像的解决方法：<br/>
　　①下载Docker：<br/>
　　　方法一：<br/>
　　　添加一个源，这个源貌似是老毛子的，里面Docker的版本还是比较全的，从它的源中下载你想要的Docker版本（偶尔也会抽疯，没办法）　</p>

<blockquote>
<pre><code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
sudo sh -c &quot;echo deb http://mirror.yandex.ru/mirrors/docker/ docker main &gt; /etc/apt/sources.list.d/docker.list&quot;
sudo apt-get update
sudo apt-get install lxc-docker-×××
</code></pre>
</blockquote>

<p><img src="media/15038329005848/15038329399736.jpg" alt=""/></p>

<p>　　方法二：<br/>
　　这是Docker官方给出的方法，没试过，可以试试　　</p>

<blockquote>
<pre><code>sudo apt-get update
sudo apt-get install wget
wget -qO- https://get.docker.com/ | sh
wget -qO- https://get.docker.com/gpg | sudo apt-key add -
</code></pre>
</blockquote>

<p>　　Docker安装完毕可以先看看是否安装成功<br/>
<img src="media/15038329005848/15038329472263.jpg" alt=""/></p>

<p>　　②下载镜像<br/>
　　下载完Docker就可以下载镜像来一发试试了，在这里你可以使用官方镜像下载：　　</p>

<blockquote>
<pre><code>sudo docker pull hello-world　 下载镜像
sudo docker run hello-world　　运行镜像
</code></pre>
</blockquote>

<p>　　run是运行一个镜像，由于刚开始使用本地没有任何镜像，Docker检测到没有会自动去Docker Hub中下载。这个命令大多数时候是抽疯的（感谢GFW）。<br/>
　　所以我推荐一个更好的方法：使用第三方镜像库。网上找了半天好像也就有一个Daocloud的可以用（真的不是广告），看来中国的Docker还需要发展几年。　　</p>

<blockquote>
<pre><code>curl -sSL https://get.daocloud.io/docker | sh
curl -sSL https://get.daocloud.io/daomonit/install.sh | sh -s 4995bde401f6afc9dc5cd89a043111079ec442bb 
sudo daomonit -token=4995bde401f6afc9dc5cd89a043111079ec442bb save-config
sudo service daomonit start
</code></pre>
</blockquote>

<p>　　然后使用dao pull 下载镜像　　</p>

<blockquote>
<pre><code>sudo dao pull ×××
sudo dao --help　　查询使用方法
</code></pre>
</blockquote>

<p>　　具体使用方法可以看<a href="http://get.daocloud.io/#install-docker">http://get.daocloud.io/#install-docker</a><br/>
　　当然最好的方法还是开个VPN，我就是使用了VPN所以这些步骤都没走，pull、push随便用无压力，哈哈哈。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELF和a.out文件格式的比较]]></title>
    <link href="weijing24.github.io/15038328822812.html"/>
    <updated>2017-08-27T19:21:22+08:00</updated>
    <id>weijing24.github.io/15038328822812.html</id>
    <content type="html"><![CDATA[
<p>　　本文讨论了 UNIX/LINUX 平台下三种主要的可执行文件格式：a.out（assembler and link editor output 汇编器和链接编辑器的输出）、COFF（Common Object File Format 通用对象文件格式）、ELF（Executable and Linking Format 可执行和链接格式）。首先是对可执行文件格式的一个综述，并通过描述 ELF 文件加载过程以揭示可执行文件内容与加载运行操作之间的关系。随后依此讨论了此三种文件格式，并着重讨论 ELF 文件的动态连接机制，其间也穿插了对各种文件格式优缺点的评价。最后对三种可执行文件格式有一个简单总结，并提出作者对可文件格式评价的一些感想。 </p>

<h2 id="toc_0">可执行文件格式综述</h2>

<p>　　相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。<br/>
　　不管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用外部文件定义的符号（变量和函数），因此重定位信息和符号信息也是需要的。一些辅助信息是可选的，如调试信息、硬件信息等。基本上任意一种可执行文件格式都是按区间保存上述信息，称为段（Segment）或节（Section）。不同的文件格式中段和节的含义可能有细微区别，但根据上下文关系可以很清楚的理解，这不是关键问题。最后，可执行文件通常都有一个文件头部以描述本文件的总体结构。<br/>
　　相对可执行文件有三个重要的概念：编译（compile）、连接（link，也可称为链接、联接）、加载（load）。源程序文件被编译成目标文件，多个目标文件被连接成一个最终的可执行文件，可执行文件被加载到内存中运行。因为本文重点是讨论可执行文件格式，因此加载过程也相对重点讨论。下面是LINUX平台下ELF文件加载过程的一个简单描述。</p>

<blockquote>
<p>1：内核首先读ELF文件的头部，然后根据头部的数据指示分别读入各种数据结构，找到标记为可加载（loadable）的段，并调用函数 mmap()把段内容加载到内存中。在加载之前，内核把段的标记直接传递给 mmap()，段的标记指示该段在内存中是否可读、可写，可执行。显然，文本段是只读可执行，而数据段是可读可写。这种方式是利用了现代操作系统和处理器对内存的保护功能。著名的Shellcode（参考资料 17）的编写技巧则是突破此保护功能的一个实际例子。<br/>
2：内核分析出ELF文件标记为 PT_INTERP 的段中所对应的动态连接器名称，并加载动态连接器。现代 LINUX 系统的动态连接器通常是 /lib/ld-linux.so.2，相关细节在后面有详细描述。<br/>
3：内核在新进程的堆栈中设置一些标记-值对，以指示动态连接器的相关操作。<br/>
4：内核把控制传递给动态连接器。<br/>
5：动态连接器检查程序对外部文件（共享库）的依赖性，并在需要时对其进行加载。<br/>
6：动态连接器对程序的外部引用进行重定位，通俗的讲，就是告诉程序其引用的外部变量/函数的地址，此地址位于共享库被加载在内存的区间内。动态连接还有一个延迟（Lazy）定位的特性，即只在&quot;真正&quot;需要引用符号时才重定位，这对提高程序运行效率有极大帮助。<br/>
7：动态连接器执行在ELF文件中标记为 .init 的节的代码，进行程序运行的初始化。在早期系统中，初始化代码对应函数 _init(void)(函数名强制固定)，在现代系统中，则对应形式为<br/>
void<br/>
__attribute((constructor))<br/>
init_function(void)<br/>
{<br/>
……<br/>
}<br/>
其中函数名为任意。<br/>
8：动态连接器把控制传递给程序，从 ELF 文件头部中定义的程序进入点开始执行。在 a.out 格式和ELF格式中，程序进入点的值是显式存在的，在 COFF 格式中则是由规范隐含定义。</p>
</blockquote>

<p>　　从上面的描述可以看出，加载文件最重要的是完成两件事情：加载程序段和数据段到内存；进行外部定义符号的重定位。重定位是程序连接中一个重要概念。我们知道，一个可执行程序通常是由一个含有 main() 的主程序文件、若干目标文件、若干共享库（Shared Libraries）组成。（注：采用一些特别的技巧，也可编写没有 main 函数的程序，请参阅参考资料 2）一个 C 程序可能引用共享库定义的变量或函数，换句话说就是程序运行时必须知道这些变量/函数的地址。在静态连接中，程序所有需要使用的外部定义都完全包含在可执行程序中，而动态连接则只在可执行文件中设置相关外部定义的一些引用信息，真正的重定位是在程序运行之时。静态连接方式有两个大问题：如果库中变量或函数有任何变化都必须重新编译连接程序；如果多个程序引用同样的变量/函数，则此变量/函数会在文件/内存中出现多次，浪费硬盘/内存空间。比较两种连接方式生成的可执行文件的大小，可以看出有明显的区别。</p>

<h2 id="toc_1">a.out 文件格式分析</h2>

<p>　　a.out 格式在不同的机器平台和不同的 UNIX 操作系统上有轻微的不同，例如在 MC680x0 平台上有 6 个 section。下面我们讨论的是最&quot;标准&quot;的格式。<br/>
　　a.out 文件包含 7 个 section，格式如下：</p>

<blockquote>
<p>exec header（执行头部，也可理解为文件头部）<br/>
text segment（文本段）<br/>
data segment(数据段)<br/>
text relocations(文本重定位段)<br/>
data relocations（数据重定位段）<br/>
symbol table（符号表）<br/>
string table（字符串表）</p>
</blockquote>

<p>执行头部的数据结构：</p>

<blockquote>
<p>struct exec {<br/>
        unsigned long   a_midmag;    /* 魔数和其它信息 <em>/<br/>
        unsigned long   a_text;      /</em> 文本段的长度 <em>/<br/>
        unsigned long   a_data;      /</em> 数据段的长度 <em>/<br/>
        unsigned long   a_bss;       /</em> BSS段的长度 <em>/<br/>
        unsigned long   a_syms;      /</em> 符号表的长度 <em>/<br/>
        unsigned long   a_entry;     /</em> 程序进入点 <em>/<br/>
        unsigned long   a_trsize;    /</em> 文本重定位表的长度 <em>/<br/>
        unsigned long   a_drsize;    /</em> 数据重定位表的长度 */<br/>
};</p>
</blockquote>

<p>　　文件头部主要描述了各个 section 的长度，比较重要的字段是 a_entry（程序进入点），代表了系统在加载程序并初试化各种环境后开始执行程序代码的入口。这个字段在后面讨论的 ELF 文件头部中也有出现。由 a.out 格式和头部数据结构我们可以看出，a.out 的格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、BSS），而且每个 section 的顺序是固定的。这种结构缺乏扩展性，如不能包含&quot;现代&quot;可执行文件中常见的调试信息，最初的 UNIX 黑客对 a.out 文件调试使用的工具是 adb，而 adb 是一种机器语言调试器！<br/>
　　a.out 文件中包含符号表和两个重定位表，这三个表的内容在连接目标文件以生成可执行文件时起作用。在最终可执行的 a.out 文件中，这三个表的长度都为 0。a.out 文件在连接时就把所有外部定义包含在可执行程序中，如果从程序设计的角度来看，这是一种硬编码方式，或者可称为模块之间是强藕和的。在后面的讨论中，我们将会具体看到ELF格式和动态连接机制是如何对此进行改进的。<br/>
　　a.out 是早期UNIX系统使用的可执行文件格式，由 AT&amp;T 设计，现在基本上已被 ELF 文件格式代替。a.out 的设计比较简单，但其设计思想明显的被后续的可执行文件格式所继承和发扬。可以参阅参考资料 16 和阅读参考资料 15 源代码加深对 a.out 格式的理解。参考资料 12 讨论了如何在&quot;现代&quot;的红帽LINUX运行 a.out 格式文件。</p>

<h2 id="toc_2">COFF 文件格式分析</h2>

<p>　　COFF 格式比 a.out 格式要复杂一些，最重要的是包含一个节段表(section table)，因此除了 .text，.data，和 .bss 区段以外，还可以包含其它的区段。另外也多了一个可选的头部，不同的操作系统可一对此头部做特定的定义。<br/>
　　COFF 文件格式如下：</p>

<blockquote>
<p>File Header(文件头部)<br/>
Optional Header(可选文件头部)<br/>
Section 1 Header(节头部)<br/>
………<br/>
Section n Header(节头部)<br/>
Raw Data for Section 1(节数据)<br/>
Raw Data for Section n(节数据)<br/>
Relocation Info for Sect. 1(节重定位数据)<br/>
Relocation Info for Sect. n(节重定位数据)<br/>
Line Numbers for Sect. 1(节行号数据)<br/>
Line Numbers for Sect. n(节行号数据)<br/>
Symbol table(符号表)<br/>
String table(字符串表)</p>
</blockquote>

<p>文件头部的数据结构：</p>

<blockquote>
<p>struct filehdr<br/>
   {<br/>
     unsigned short  f_magic;    /* 魔数 <em>/<br/>
       unsigned short  f_nscns;    /</em> 节个数 <em>/<br/>
       long            f_timdat;   /</em> 文件建立时间 <em>/<br/>
       long            f_symptr;   /</em> 符号表相对文件的偏移量 <em>/<br/>
       long            f_nsyms;    /</em> 符号表条目个数 <em>/<br/>
       unsigned short  f_opthdr;   /</em> 可选头部长度 <em>/<br/>
       unsigned short  f_flags;    /</em> 标志 */<br/>
   };</p>
</blockquote>

<p>　　COFF 文件头部中魔数与其它两种格式的意义不太一样，它是表示针对的机器类型，例如 0x014c 相对于 I386 平台，而 0x268 相对于 Motorola 68000系列等。当 COFF 文件为可执行文件时，字段 f_flags 的值为 F_EXEC（0X00002），同时也表示此文件没有未解析的符号，换句话说，也就是重定位在连接时就已经完成。由此也可以看出，原始的 COFF 格式不支持动态连接。为了解决这个问题以及增加一些新的特性，一些操作系统对 COFF 格式进行了扩展。Microsoft 设计了名为 PE（Portable Executable）的文件格式，主要扩展是在 COFF 文件头部之上增加了一些专用头部，具体细节请参阅参考资料 18，某些 UNIX 系统也对 COFF 格式进行了扩展，如 XCOFF（extended common object file format）格式，支持动态连接，请参阅参考资料 5。<br/>
　　紧接文件头部的是可选头部，COFF 文件格式规范中规定可选头部的长度可以为 0，但在 LINUX 系统下可选头部是必须存在的。下面是 LINUX 下可选头部的数据结构：</p>

<blockquote>
<p>typedef struct <br/>
{<br/>
    char   magic[2];    /* 魔数 <em>/<br/>
    char   vstamp[2];    /</em> 版本号 <em>/<br/>
    char   tsize[4];    /</em> 文本段长度 <em>/<br/>
    char   dsize[4];    /</em> 已初始化数据段长度 <em>/<br/>
    char   bsize[4];    /</em> 未初始化数据段长度 <em>/<br/>
    char   entry[4];    /</em> 程序进入点 <em>/<br/>
    char   text_start[4];       /</em> 文本段基地址 <em>/<br/>
    char   data_start[4];       /</em> 数据段基地址 */<br/>
}<br/>
COFF_AOUTHDR;</p>
</blockquote>

<p>　　字段 magic 为 0413 时表示 COFF 文件是可执行的，注意到可选头部中显式定义了程序进入点，标准的 COFF 文件没有明确的定义程序进入点的值，通常是从 .text 节开始执行，但这种设计并不好。<br/>
　　前面我们提到，COFF 格式比 a.out 格式多了一个节段表，一个节头条目描述一个节数据的细节，因此 COFF 格式能包含更多的节，或者说可以根据实际需要，增加特定的节，具体表现在 COFF 格式本身的定义以及稍早提及的 COFF 格式扩展。我个人认为，节段表的出现可能是 COFF 格式相对 a.out 格式最大的进步。下面我们将简单描述 COFF 文件中节的数据结构，因为节的意义更多体现在程序的编译和连接上，所以本文不对其做更多的描述。此外，ELF 格式和 COFF格式对节的定义非常相似，在随后的 ELF 格式分析中，我们将省略相关讨论。</p>

<blockquote>
<p>struct COFF_scnhdr <br/>
{<br/>
    char s_name[8];     /* 节名称 <em>/<br/>
    char s_paddr[4];    /</em> 物理地址 <em>/<br/>
   char s_vaddr[4];    /</em> 虚拟地址 <em>/<br/>
    char s_size[4];     /</em> 节长度 <em>/<br/>
   char s_scnptr[4];    /</em> 节数据相对文件的偏移量 <em>/<br/>
    char s_relptr[4];    /</em> 节重定位信息偏移量 <em>/<br/>
    char s_lnnoptr[4];    /</em> 节行信息偏移量 <em>/<br/>
    char s_nreloc[2];    /</em> 节重定位条目数 <em>/<br/>
    char s_nlnno[2];    /</em> 节行信息条目数 <em>/<br/>
    char s_flags[4];    /</em> 段标记 */<br/>
};</p>
</blockquote>

<p>　　有一点需要注意：LINUX系统中头文件coff.h中对字段 s_paddr的注释是&quot;physical address&quot;，但似乎应该理解为&quot;节被加载到内存中所占用的空间长度&quot;。字段s_flags标记该节的类型，如文本段、数据段、BSS段等。在 COFF的节中也出现了行信息，行信息描述了二进制代码与源代码的行号之间的对映关系，在调试时很有用。<br/>
参考资料 19是一份对COFF格式详细描述的中文资料，更详细的内容请参阅参考资料 20。</p>

<h2 id="toc_3">ELF文件格式分析</h2>

<p>　　ELF文件有三种类型：可重定位文件：也就是通常称的目标文件，后缀为.o。共享文件：也就是通常称的库文件，后缀为.so。可执行文件：本文主要讨论的文件格式，总的来说，可执行文件的格式与上述两种文件的格式之间的区别主要在于观察的角度不同：一种称为连接视图（Linking View），一种称为执行视图（Execution View）。<br/>
　　首先看看ELF文件的总体布局：</p>

<blockquote>
<p>ELF header(ELF头部)<br/>
Program header table(程序头表)<br/>
Segment1（段1）<br/>
Segment2（段2）<br/>
………<br/>
Sengmentn（段n）<br/>
Setion header table(节头表，可选)</p>
</blockquote>

<p>　　段由若干个节(Section)构成,节头表对每一个节的信息有相关描述。对可执行程序而言，节头表是可选的。参考资料 1中作者谈到把节头表的所有数据全部设置为0，程序也能正确运行！ELF头部是一个关于本文件的路线图（road map），从总体上描述文件的结构。下面是ELF头部的数据结构：</p>

<blockquote>
<p>typedef struct<br/>
{<br/>
    unsigned char e_ident[EI_NIDENT];     /* 魔数和相关信息 <em>/<br/>
    Elf32_Half    e_type;                 /</em> 目标文件类型 <em>/<br/>
    Elf32_Half    e_machine;              /</em> 硬件体系 <em>/<br/>
    Elf32_Word    e_version;              /</em> 目标文件版本 <em>/<br/>
    Elf32_Addr    e_entry;                /</em> 程序进入点 <em>/<br/>
    Elf32_Off     e_phoff;                /</em> 程序头部偏移量 <em>/<br/>
    Elf32_Off     e_shoff;                /</em> 节头部偏移量 <em>/<br/>
    Elf32_Word    e_flags;                /</em> 处理器特定标志 <em>/<br/>
    Elf32_Half    e_ehsize;               /</em> ELF头部长度 <em>/<br/>
    Elf32_Half    e_phentsize;            /</em> 程序头部中一个条目的长度 <em>/<br/>
    Elf32_Half    e_phnum;                /</em> 程序头部条目个数  <em>/<br/>
    Elf32_Half    e_shentsize;            /</em> 节头部中一个条目的长度 <em>/<br/>
    Elf32_Half    e_shnum;                /</em> 节头部条目个数 <em>/<br/>
    Elf32_Half    e_shstrndx;             /</em> 节头部字符表索引 */<br/>
} Elf32_Ehdr;</p>
</blockquote>

<p>　　下面我们对ELF头表中一些重要的字段作出相关说明，完整的ELF定义请参阅参考资料 6和参考资料7。<br/>
　　e_ident[0]-e_ident[3]包含了ELF文件的魔数，依次是0x7f、&#39;E&#39;、&#39;L&#39;、&#39;F&#39;。注意，任何一个ELF文件必须包含此魔数。参考资料 3中讨论了利用程序、工具、/Proc文件系统等多种查看ELF魔数的方法。e_ident[4]表示硬件系统的位数，1代表32位，2代表64位。 e_ident[5]表示数据编码方式，1代表小印第安排序（最大有意义的字节占有最低的地址），2代表大印第安排序（最大有意义的字节占有最高的地址）。e_ident[6]指定ELF头部的版本，当前必须为1。e_ident[7]到e_ident[14]是填充符，通常是0。ELF格式规范中定义这几个字节是被忽略的，但实际上是这几个字节完全可以可被利用。如病毒Lin/Glaurung.676/666（参考资料 1）设置e_ident[7]为0x21,表示本文件已被感染；或者存放可执行代码（参考资料 2）。ELF头部中大多数字段都是对子头部数据的描述，其意义相对比较简单。值得注意的是某些病毒可能修改字段e_entry（程序进入点）的值，以指向病毒代码，例如上面提到的病毒Lin/Glaurung.676/666。<br/>
　　一个实际可执行文件的文件头部形式如下：（利用命令readelf）</p>

<blockquote>
<p>ELF Header:<br/>
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 <br/>
   Class:                             ELF32<br/>
   Data:                              2&#39;s complement, little endian<br/>
   Version:                           1 (current)<br/>
   OS/ABI:                            UNIX - System V<br/>
   ABI Version:                       0<br/>
   Type:                              EXEC (Executable file)<br/>
   Machine:                           Intel 80386<br/>
   Version:                           0x1<br/>
   Entry point address:               0x80483cc<br/>
   Start of program headers:          52 (bytes into file)<br/>
   Start of section headers:          14936 (bytes into file)<br/>
   Flags:                             0x0<br/>
   Size of this header:               52 (bytes)<br/>
   Size of program headers:           32 (bytes)<br/>
   Number of program headers:         6<br/>
   Size of section headers:           40 (bytes)<br/>
   Number of section headers:         34<br/>
   Section header string table index: 31</p>
</blockquote>

<p>　　紧接ELF头部的是程序头表，它是一个结构数组，包含了ELF头表中字段e_phnum定义的条目，结构描述一个段或其他系统准备执行该程序所需要的信息。</p>

<blockquote>
<p>typedef struct {<br/>
      Elf32_Word  p_type;    /* 段类型 */<br/>
      Elf32_Off   p_offset;        /* 段位置相对于文件开始处的偏移量 */<br/>
      Elf32_Addr  p_vaddr;      /* 段在内存中的地址 */<br/>
      Elf32_Addr  p_paddr;      /* 段的物理地址 */<br/>
      Elf32_Word  p_filesz;    /* 段在文件中的长度 */<br/>
      Elf32_Word  p_memsz;    /* 段在内存中的长度 */<br/>
      Elf32_Word  p_flags;    /* 段的标记 */<br/>
      Elf32_Word  p_align;    /* 段在内存中对齐标记 */<br/>
  } Elf32_Phdr;</p>
</blockquote>

<p>在详细讨论可执行文件程序头表之前，首先查看一个实际文件的输出：</p>

<blockquote>
<p>Program Headers:<br/>
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align<br/>
PHDR           0x000034 0x08048034 0x08048034 0x000c0 0x000c0 R E 0x4<br/>
INTERP         0x0000f4 0x080480f4 0x080480f4 0x00013 0x00013 R   0x1<br/>
      [Requesting program interpreter: /lib/ld-linux.so.2]<br/>
   LOAD           0x000000 0x08048000 0x08048000 0x00684 0x00684 R E 0x1000<br/>
   LOAD           0x000684 0x08049684 0x08049684 0x00118 0x00130 RW  0x1000<br/>
   DYNAMIC        0x000690 0x08049690 0x08049690 0x000c8 0x000c8 RW  0x4<br/>
   NOTE           0x000108 0x08048108 0x08048108 0x00020 0x00020 R   0x4<br/>
  Section to Segment mapping:<br/>
  Segment Sections...<br/>
   00<br/><br/>
   01     .interp <br/>
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt <br/>
.init .plt .text .fini .rodata .eh_frame <br/>
   03     .data .dynamic .ctors .dtors .jcr .got .bss <br/>
   04     .dynamic <br/>
05     .note.ABI-tag<br/>
Section Headers:<br/>
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al<br/>
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0<br/>
  [ 1] .interp           PROGBITS        080480f4 0000f4 000013 00   A  0   0  1<br/>
  [ 2] .note.ABI-tag     NOTE            08048108 000108 000020 00   A  0   0  4<br/>
  [ 3] .hash             HASH            08048128 000128 000040 04   A  4   0  4<br/>
  [ 4] .dynsym           DYNSYM          08048168 000168 0000b0 10   A  5   1  4<br/>
  [ 5] .dynstr           STRTAB          08048218 000218 00007b 00   A  0   0  1<br/>
  [ 6] .gnu.version      VERSYM          08048294 000294 000016 02   A  4   0  2<br/>
  [ 7] .gnu.version_r    VERNEED         080482ac 0002ac 000030 00   A  5   1  4<br/>
  [ 8] .rel.dyn          REL             080482dc 0002dc 000008 08   A  4   0  4<br/>
  [ 9] .rel.plt          REL             080482e4 0002e4 000040 08   A  4   b  4<br/>
  [10] .init             PROGBITS        08048324 000324 000017 00  AX  0   0  4<br/>
  [11] .plt              PROGBITS        0804833c 00033c 000090 04  AX  0   0  4<br/>
  [12] .text             PROGBITS        080483cc 0003cc 0001f8 00  AX  0   0  4<br/>
  [13] .fini             PROGBITS        080485c4 0005c4 00001b 00  AX  0   0  4<br/>
  [14] .rodata           PROGBITS        080485e0 0005e0 00009f 00   A  0   0 32<br/>
  [15] .eh_frame         PROGBITS        08048680 000680 000004 00   A  0   0  4<br/>
  [16] .data             PROGBITS        08049684 000684 00000c 00  WA  0   0  4<br/>
  [17] .dynamic          DYNAMIC         08049690 000690 0000c8 08  WA  5   0  4<br/>
  [18] .ctors            PROGBITS        08049758 000758 000008 00  WA  0   0  4<br/>
  [19] .dtors            PROGBITS        08049760 000760 000008 00  WA  0   0  4<br/>
  [20] .jcr              PROGBITS        08049768 000768 000004 00  WA  0   0  4<br/>
  [21] .got              PROGBITS        0804976c 00076c 000030 04  WA  0   0  4<br/>
  [22] .bss              NOBITS          0804979c 00079c 000018 00  WA  0   0  4<br/>
  [23] .comment          PROGBITS        00000000 00079c 000132 00      0   0  1<br/>
  [24] .debug_aranges    PROGBITS        00000000 0008d0 000098 00      0   0  8<br/>
  [25] .debug_pubnames   PROGBITS        00000000 000968 000040 00      0   0  1<br/>
  [26] .debug_info       PROGBITS        00000000 0009a8 001cc6 00      0   0  1<br/>
  [27] .debug_abbrev     PROGBITS        00000000 00266e 0002cc 00      0   0  1<br/>
  [28] .debug_line       PROGBITS        00000000 00293a 0003dc 00      0   0  1<br/>
  [29] .debug_frame      PROGBITS        00000000 002d18 000048 00      0   0  4<br/>
  [30] .debug_str        PROGBITS        00000000 002d60 000bcd 01  MS  0   0  1<br/>
  [31] .shstrtab         STRTAB          00000000 00392d 00012b 00      0   0  1<br/>
  [32] .symtab           SYMTAB          00000000 003fa8 000740 10     33  56  4<br/>
  [33] .strtab           STRTAB          00000000 0046e8 000467 00      0   0  1</p>
</blockquote>

<p>　　对一个ELF可执行程序而言，一个基本的段是标记p_type为PT_INTERP的段，它表明了运行此程序所需要的程序解释器（/lib/ld- linux.so.2），实际上也就是动态连接器（dynamic linker）。最重要的段是标记p_type为PT_LOAD的段，它表明了为运行程序而需要加载到内存的数据。查看上面实际输入，可以看见有两个可 LOAD段，第一个为只读可执行（FLg为R E）,第二个为可读可写（Flg为RW）。段1包含了文本节.text，注意到ELF文件头部中程序进入点的值为0x80483cc，正好是指向节. text在内存中的地址。段二包含了数据节.data，此数据节中数据是可读可写的，相对的只读数据节.rodata包含在段1中。ELF格式可以比 COFF格式包含更多的调试信息，如上面所列出的形式为.debug_xxx的节。在I386平台LINUX系统下，用命令file查看一个ELF可执行程序的可能输出是：a.out: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.2.5, dynamically linked (uses shared libs), not stripped。按照这个说法来说 a.out和elf两种格式得可执行文件得结构都不一样呀。他文章里还有一段话：</p>

<blockquote>
<p>不同时期的可执行文件格式深刻的反映了技术进步的过程，技术进步通常是针对解决存在的问题和适应新的环境。早期的UNIX系统使用a.out格式，随着操作系统和硬件系统的进步，a.out格式的局限性越来越明显。新的可执行文件格式COFF在UNIX System VR3中出现，COFF格式相对a.out格式最大变化是多了一个节头表（section head table），能够在包含基础的文本段、数据段、BSS段之外包含更多的段，但是COFF对动态连接和C++程序的支持仍然比较困难。为了解决上述问题， UNIX系统实验室(UNIX SYSTEM Laboratories USL) 开发出ELF文件格式，它被作为应用程序二进制接口（Application binary Interface ABI）的一部分，其目的是替代传统的a.out格式。例如，ELF文件格式中引入初始化段.init和结束段.fini（分别对应构造函数和析构函数）则主要是为了支持C++程序。1994年6月ELF格式出现在LINUX系统上，现在ELF格式作为UNIX/LINUX最主要的可执行文件格式。当然我们完全有理由相信，在将来还会有新的可执行文件格式出现。</p>
</blockquote>

<p>　　所以我就更觉得elf是一种更新得更效率得替代a.out技术吧,至于gcc/g++生成得a.out是不是elf<br/>
　　我按照图片得样子查看了个a.out，完全符合elf得数据结构</p>

<blockquote>
<p>sunsky727@ubuntu:~/io$ readelf -h a.out<br/>
ELF Header:<br/>
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br/>
  Class:                             ELF64<br/>
  Data:                              2&#39;s complement, little endian<br/>
  Version:                           1 (current)<br/>
  OS/ABI:                            UNIX - System V<br/>
  ABI Version:                       0<br/>
  Type:                              EXEC (Executable file)<br/>
  Machine:                           Advanced Micro Devices X86-64<br/>
  Version:                           0x1<br/>
  Entry point address:               0x4007f0<br/>
  Start of program headers:          64 (bytes into file)<br/>
  Start of section headers:          6736 (bytes into file)<br/>
  Flags:                             0x0<br/>
  Size of this header:               64 (bytes)<br/>
  Size of program headers:           56 (bytes)<br/>
  Number of program headers:         8<br/>
  Size of section headers:           64 (bytes)<br/>
  Number of section headers:         37<br/>
  Section header string table index: 34</p>
</blockquote>

<p>看来a.out就像权哥说得那样只是个名字！！！！用的就是elf</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (七) Cookie]]></title>
    <link href="weijing24.github.io/15038327056467.html"/>
    <updated>2017-08-27T19:18:25+08:00</updated>
    <id>weijing24.github.io/15038327056467.html</id>
    <content type="html"><![CDATA[
<p>Cookie是HTTP协议中非常重要的东西， 之前拜读了Fish Li 写的<a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html">细说Cookie</a>， 让我学到了很多东西。Fish的这篇文章写得太经典了。 所以我这篇文章就没有太多内容了。 <br/>
最近我打算写一个系列的HTTP文章，我站在HTTP协议的角度， 说说我对Cookie的理解。</p>

<h3 id="toc_0">Cookie是什么，有什么用，为什么要用到Cookie</h3>

<p>请看Fish Li 写的<a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html">细说Cookie</a></p>

<h3 id="toc_1">Cookie的分类</h3>

<p>可以大致把Cookie分为2类： 回话cookie和持久cookie<br/>
会话cookie: 是一种临时的cookie，它记录了用户访问站点时的设置和偏好，关闭浏览器，会话cookie就被删除了<br/>
持久cookie: 存储在硬盘上，（不管浏览器退出，或者电脑重启，持久cookie都存在）， 持久cookie有过期时间</p>

<h3 id="toc_2">Cookie存在哪里</h3>

<p>Cookie是存在硬盘上，  IE存cookie的地方和Firefox存cookie的地方不一样。  不同的操作系统也可能存cookie的地方不一样。<br/>
不同的浏览器会在各自的独立空间存放Cookie, 互不干涉<br/>
以我的windows7， IE8为例，  cookie存在这： C:\Users\xiaoj\AppData\Local\Microsoft\Windows\Temporary Internet Files<br/>
注意： 缓存文件和cookie文件，是存在一起的, 都在这个目录下。<br/>
你也可以这样找, 打开IE，点击Tools-&gt;Internet Options-&gt;General Tab下的-&gt;Browsing history下的Setting按钮，弹出的对话框中点击View files.<br/>
<img src="media/15038327056467/15038327504167.jpg" alt=""/><br/>
不同的网站会有不同的cookie文件<br/>
<img src="media/15038327056467/15038328209258.jpg" alt=""/></p>

<h3 id="toc_3">使用和禁用Cookie</h3>

<p>IE:   工具-&gt;Internet 选项 -&gt; 隐私<br/>
<img src="media/15038327056467/15038327401476.jpg" alt=""/></p>

<h3 id="toc_4">Fiddler查看HTTP中的Cookie</h3>

<p>浏览器把cookie通过HTTP Request 中的“Cookie: header”发送给Web服务器<br/>
Web服务器通过HTTP Response中的&quot;Set-Cookie: header&quot;把cookie发送给浏览器<br/>
使用Fiddler可以清楚地看到cookie在HTTP中传递。 Fiddler工具中可以清晰的看到Http Request 中的Cookie， 和Http Response中的cookie<br/><br/>
实例： 启动Fiddler,  启动浏览器访问一些购物网站，就可以看到。<br/>
<img src="media/15038327056467/15038328374970.jpg" alt=""/></p>

<h3 id="toc_5">网站自动登陆的原理</h3>

<p>我们以”博客园自动登陆“的例子，来说明cookie是如何传递的。<br/>
大家知道博客园是可以自动登陆的。 如下图，这个是什么原理呢?<br/>
<img src="media/15038327056467/15038328427264.jpg" alt=""/></p>

<p>假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。（这时候，其实在你的机器上保存好了登陆的cookie, 不信你可以按照上节介绍方法去你的电脑上找下博客园的cookie）<br/><br/>
当我下次访问博客园流程如下。</p>

<ol>
<li>用户打开IE浏览器，在地址栏上输入www.cnblogs.com.</li>
<li>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</li>
<li>Web服务器返回博客园首页（你会看到你已经登陆了）。</li>
</ol>

<p><img src="media/15038327056467/15038328501782.jpg" alt=""/></p>

<h3 id="toc_6">截获Cookie，冒充别人身份</h3>

<p>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢？  当然可以， 这就是一种黑客技术叫Cookie欺骗。<br/>
利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。<br/>
我知道有两种方法可以截获他人的cookie，</p>

<ol>
<li>通过XSS脚步攻击， 获取他人的cookie. 具体原理可以看 [Web安全性测试之XSS]</li>
<li>想办法获取别人电脑上保存的cookie文件（这个比较难）</li>
</ol>

<p>拿到cookie后，就可以冒充别人的身份了。 这个过程我就不演示了。</p>

<h3 id="toc_7">Cookie和文件缓存的区别</h3>

<p>很多人会把cookie和文件缓存弄混淆， 这两个完全是不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且是存在同一个文件夹下。<br/>
关于HTTP缓存请看这 【HTTP协议之缓存】<br/>
我们在IE中可以选择分别删除Cookie和缓存文件<br/>
<img src="media/15038327056467/15038328592628.jpg" alt=""/></p>

<h3 id="toc_8">Cookie 泄露隐私</h3>

<p>2013年央视的315晚会上， 曝光了很多不法公司利用Cookie跟踪并采集用户的个人信息，并转卖给网络广告商，形成了一条窃取用户信息的灰色产业链。从而实现广告准确投放。严重干扰了用户的正常网络应用，侵害了个人的隐私和利益。<br/>
我经常就在门户网站上发现广告位上显示的是我在电商网站上流量过的商品。  这就是我的cookie被泄露了。<br/>
目前在欧洲， 已经对Cookie立法， 如果网站需要保存用户的cookie, 必须弹出一个对话框，要用户确认后才能保存Cookie.</p>

<h3 id="toc_9">P3P协议</h3>

<p>从上面看来， Cookie 是一个比较容易泄露用户隐私和危险的东西。  有没有办法保护个人用户隐私呢？    那就是P3P协议<br/>
P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个 站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网 所开发的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (六) 状态码详解]]></title>
    <link href="weijing24.github.io/15038326831174.html"/>
    <updated>2017-08-27T19:18:03+08:00</updated>
    <id>weijing24.github.io/15038326831174.html</id>
    <content type="html"><![CDATA[
<p>HTTP状态码，我都是现查现用。 我以前记得几个常用的状态码，比如200，302，304，404， 503。 一般来说我也只需要了解这些常用的状态码就可以了。  如果是做AJAX，REST,网络爬虫，机器人等程序。还是需要了解其他状态码。  本文我花了一个多月的时间把所有的状态码都总结了下，内容太多，看的时候麻烦耐心点了。<br/>
HTTP状态码的学习资料到处都有，但是都是理论上讲解。  本文介绍HTTP协议中的HTTP状态码（HTTP Status Code）， 会对大部分的状态码都进行了详细的实例讲解。<br/>
要了解状态码，应该在实例中去理解状态码的意义，否则看了也会忘记的。</p>

<h3 id="toc_0">什么是HTTP状态码</h3>

<p>HTTP状态码的作用是：Web服务器用来告诉客户端，发生了什么事。<br/>
状态码位于HTTP Response 的第一行中，会返回一个”三位数字的状态码“和一个“状态消息”。 ”三位数字的状态码“便于程序进行处理， “状态消息”更便于人理解。 <br/>
如下图，  当客户端请求一个不存在的URL的时候， Web服务器会返回 “HTTP/1.1 404 Not Found” 告诉浏览器客户端。 服务器无法找到所请求的URL。</p>

<h3 id="toc_1">状态码分类</h3>

<p>HTTP状态码被分为五大类， 目前我们使用的HTTP协议版本是1.1， 支持以下的状态码。随着协议的发展，HTTP规范中会定义更多的状态码。 <br/>
小技巧：  假如你看到一个状态码518， 你并不知道具体518是什么意思。 这时候你只要知道518是属于（5XX，服务器错误就可以了）</p>

<p>常见的状态码<br/>
一般人只需要了解以下常见的状态码就够了， 如果你想了解更多， 请继续往下看。<br/>
200 OK 服务器成功处理了请求（这个是我们见到最多的）<br/>
301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置<br/>
304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存<br/>
404 Not Found 未找到资源<br/>
501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</p>

<h3 id="toc_2">1XX 信息性状态码</h3>

<p>这些状态码是HTTP 1.1引入的。 对于这些状态码的价值还存在争论 （我个人从来没见过这些状态码， 也没有理解这些状态码。）</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th> 状态消息</th>
<th> 含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>100</td>
<td>Continue(继续)</td>
<td>收到了请求的起始部分，客户端应该继续请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols（切换协议</td>
<td>服务器正根据客户端的指示将协议切换成Update Header列出的协议</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">2XX 成功状态码</h3>

<p>客户端发起请求时， 这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>200</td>
<td>ok</td>
<td>服务器成功处理了请求</td>
</tr>
<tr>
<td>201</td>
<td>created(已创建)</td>
<td>对于那些要服务器创建对象的请求来说，资源已创建完毕。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted(已接受)</td>
<td>请求已接受，但服务器尚未处理</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information（非权威信息)</td>
<td>服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content(没有内容)</td>
<td>Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content(重置内容)</td>
<td>另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content（部分内容)</td>
<td>部分请求成功</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">3XX 重定向状态码</h3>

<p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。<br/>
浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。<br/>
301和302 非常相似，  一个是永久转移，一个是临时转移。<br/><br/>
（SEO中，搜索引擎如果碰到301， 比如网页A用301重定向到网页B，搜索引擎可以肯定网页A永久性改变地址，就会把网页B当做唯一有效目标）<br/>
302，303，307 是一样。  这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307. 同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）<br/>
所以这一节， 我们只需要掌握302， 304 就可以了。</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>300</td>
<td>Multiple Choices（多项选择）</td>
<td>客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently（永久移除)</td>
<td>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td>
</tr>
<tr>
<td>302</td>
<td>Found（已找到）</td>
<td>与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request</td>
</tr>
<tr>
<td>303</td>
<td>See Other（参见其他）</td>
<td>类似302</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified（未修改）</td>
<td>客户的缓存资源是最新的， 要客户端使用缓存</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy（使用代理）</td>
<td>必须通过代理访问资源， 代理的地址在Response 的Location中</td>
</tr>
<tr>
<td>306</td>
<td>未使用</td>
<td>这个状态码当前没使用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect（临时重定向）</td>
<td>类似302</td>
</tr>
</tbody>
</table>

<h3 id="toc_5">4XX客户端错误状态码</h3>

<p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL。</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>400</td>
<td>Bad Request（坏请求）</td>
<td>告诉客户端，它发送了一个错误的请求。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要客户端对自己认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required（要求付款）</td>
<td>这个状态还没被使用， 保留给将来用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden（禁止）</td>
<td>请求被服务器拒绝了</td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>未找到资源</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed（不允许使用的方法）</td>
<td>不支持该Request的方法。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable（无法接受）</td>
<td></td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required(要求进行代理认证)</td>
<td>与状态码401类似， 用于需要进行认证的代理服务器</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout（请求超时）</td>
<td>如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td>
</tr>
<tr>
<td>409</td>
<td>Conflict（冲突）</td>
<td>发出的请求在资源上造成了一些冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone（消失了）</td>
<td>服务器曾经有这个资源，现在没有了，与状态码404类似</td>
</tr>
<tr>
<td>411</td>
<td>Length Required（要求长度指示）</td>
<td>服务器要求在Request中包含Content-Length。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed（先决条件失败）</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large（请求实体太大）</td>
<td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td>
</tr>
<tr>
<td>414</td>
<td>Request URI Too Long（请求URI太长）</td>
<td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type（不支持的媒体类型）</td>
<td>服务器无法理解或不支持客户端所发送的实体的内容类型</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable（所请求的范围未得到满足）</td>
<td></td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed（无法满足期望）</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_6">5XX服务器错误状态码</h3>

<p>有时候客户端发送了一条有效Request, Web服务器自身却出错了。 可能是Web服务器运行出错了， 或者网站都挂了。  5XX就是用来描述服务器错误的。</p>

<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
</tr>
</thead>

<tbody>
<tr>
<td>500</td>
<td>Internal Server Error(内部服务器错误)</td>
<td>服务器遇到一个错误，使其无法为请求提供服务</td>
</tr>
<tr>
<td>501   Not Implemented（未实现）</td>
<td>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。</td>
<td></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway（网关故障）</td>
<td>代理使用的服务器遇到了上游的无效响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable（未提供此服务）</td>
<td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout（网关超时）</td>
<td>与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td>
</tr>
<tr>
<td>505   HTTP Version Not Supported（不支持的HTTP版本）</td>
<td>服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_7">204 No Content(没有内容)</h3>

<p>返回的Response中只有一些Header和一个状态行， 没有实体的主题内容（没有response body）<br/>
204状态码的作用在于： </p>

<ol>
<li>在不获取资源的情况下了解资源的情况（比如判断其类型）</li>
<li>通过查看Response中的状态码， 看看某个对象是否存在</li>
<li>通过查看Header, 测试资源是否被修改了。</li>
</ol>

<p>实例：先打开Fiddler, 然后启动浏览器访问ditu.google.cn,  你会捕获到很多204</p>

<h3 id="toc_8">206 Partial Content(部分内容)</h3>

<p>206状态码代表服务器已经成功处理了部分GET请求（只有发送GET 方法的request, web服务器才可能返回206），<br/>
应用场景：</p>

<ol>
<li>FlashGet, 迅雷或者HTTP下载工具都是使用206状态码来实现断点续传</li>
<li>将以个大文档分解为多个下载段同时下载 比如，在线看视频</li>
</ol>

<p>实例：　一些流媒体技术比如在线视频，可以边看边下载。　就是使用206来实现的。<br/>
打开Fiddler， 然后用浏览器打开“搜狐视频中的绿箭侠” <a href="http://tv.sohu.com/20121011/n354681393.shtml">http://tv.sohu.com/20121011/n354681393.shtml</a> 然后你在Fiddler中就能看到一堆的206<br/>
1. 浏览器发送一个Get 方法的request.  header中包含 Range: bytes=5303296-5336063. (意思就是请求得到5303296-5336063这个范围的数据)。<br/>
2. Web服务器返回一个206 的Response. header中包含Content-Range: bytes 5303296-5336063/12129376(表明这次返回的内容范围)</p>

<h3 id="toc_9">301 Moved Permanently（永久移除)</h3>

<p>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置例如：  </p>

<ol>
<li>浏览器客户端访问 <a href="http://map.google.cn">http://map.google.cn</a></li>
<li>Web服务器返回Response 301，Location=<a href="http://titu.google.cn">http://titu.google.cn</a>  （告诉客户端我们的资源位于这里， ）</li>
<li>浏览器客户端会自动再发送一个Request 去访问<a href="http://titu.google.cn">http://titu.google.cn</a></li>
</ol>

<h3 id="toc_10">400 Bad Request（坏请求)</h3>

<p>发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)，  这个我们也经常见到。 <br/>
实例： 还没想到， 想到了再贴个实例上来。</p>

<h3 id="toc_11">403 Forbidden(禁止)</h3>

<p>Web客户端发送的请求被Web服务器拒绝了， 如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是服务器不想说明拒绝原因。<br/>
访问下面的URL， 会被服务器拒绝. 并且返回403状态码<br/>
<a href="http://t2.baidu.com/it/u=1791561788,200960144&amp;fm=0&amp;gp=0.jpg">http://t2.baidu.com/it/u=1791561788,200960144&amp;fm=0&amp;gp=0.jpg</a></p>

<h3 id="toc_12">404 Page not Found (请求的资源不存在)</h3>

<p>这个大家都懂的， 值得一提的是腾讯把404页面做成了“寻找被拐儿童”</p>

<h3 id="toc_13">405 Method Not Allowed(不允许使用的方法)</h3>

<p>405是指Web服务器不支持Request中的方法。<br/>
我个人认为状态码405Method Not Allowed和501 Not Implemented 是一样的意思。都是不支持Request的方法。 （目前我还不知道这两个的区别）<br/>
实例:  发送一个是trace方法的Request 给www.google.com</p>

<h3 id="toc_14">411 Length Required（要求长度指示）</h3>

<p>服务器要求在Request中包含Content-Length。<br/>
当浏览器使用Post方法，发送数据给Web服务器时， 必须要有Content-Length。这样Web服务器才知道你要发送多少数据，否则Web服务器会返回411状态码<br/>
实例： 发送一个Post方法的Request 给www.google.com.   Request中没有Content-Length</p>

<h3 id="toc_15">413 Request Entity Too Large（请求实体太大）</h3>

<p>作用：客户端发送的实体主体部分比服务器能够或者希望处理的要大。  一般情况下我们看不到这个状态码。 因为浏览器不会发送太大的数据给网站，但是机器人可能会。<br/>
实例: 用post方法发送一个大文件(100MB以上)给www.google.com</p>

<h3 id="toc_16">414 Request URI Too Long(请求URI太长)</h3>

<p>就是说Request URI太长， 一般浏览器本身对URI的长度就会有限制，所以不会发送URI很长的Request. 我们平常是根本看不到414错误的。 但是机器人可以发送很长URI。<br/>
例如：我们用Fiddler Composer发送一个很长的URI给Google, 比如 &quot;<a href="http://www.google.com?q=asdfasdasf..">www.google.com?q=asdfasdasf..</a>&quot;  q=后面的参数很长。 就可以看到414了</p>

<h3 id="toc_17">500 Internal Server Error(内部服务器错误)</h3>

<p>这个太常见了， 我们开发网站的时候，当我们的程序出错了时，就会返回500错误。<br/>
实例：ASP.NET 程序出错</p>

<h3 id="toc_18">501 Not Implemented(未实现)</h3>

<p>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码）。  一般的Web服务器只支持GET和POST方法。<br/>
实例： 使用Fiddler Composer 给www.qq.com,  发送一个OPTIONS 方法的Request.   服务器就能返回501了。</p>

<h3 id="toc_19">502 Bad Gateway（网关故障）</h3>

<p>代理使用的服务器遇到了上游的无效响应。<br/><br/>
Fiddler本身就是代理服务器。  当我们访问www.facebook.com，这网站被我们天朝屏蔽了。 所以我们可以得到502</p>

<h3 id="toc_20">505 HTTP Version Not Supported(不支持的HTTP版本)</h3>

<p>表示Web服务器不支持此HTTP协议的版本。<br/><br/>
众所周知我们现在使用的HTTP协议版本是HTTP/1.1， 如果我们发送一个HTTP/2.0 的request 给博客园， 博客园肯定不能支持HTTP/2.0，所以会返回505 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (五) 代理]]></title>
    <link href="weijing24.github.io/15038326274764.html"/>
    <updated>2017-08-27T19:17:07+08:00</updated>
    <id>weijing24.github.io/15038326274764.html</id>
    <content type="html"><![CDATA[
<p>这次介绍代理服务器， 代理服务器是HTTP协议中一个重要的组件， 发挥着重要的作用。 本文介绍一些HTTP代理服务器的概念和工作原理</p>

<h3 id="toc_0">什么是代理服务器</h3>

<p>Web代理（proxy）服务器是网络的中间实体。 代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。<br/>
HTTP的代理服务器即是Web服务器又是Web客户端。<br/>
<img src="media/15038326274764/15038326468612.jpg" alt=""/></p>

<h3 id="toc_1">Fiddler就是个典型的代理</h3>

<p>Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。<br/>
<img src="media/15038326274764/15038326507435.jpg" alt=""/><br/>
<img src="media/15038326274764/15038326553194.jpg" alt=""/></p>

<h3 id="toc_2">代理的作用一， FQ</h3>

<p>很多人都喜欢用Facebook， 看youTube。但是我们在天朝，天朝有The Great of Wall(长城防火墙)，屏蔽了这些好网站。  怎么办?   通过代理来跳墙，就可以访问了。<br/>
自己去寻找代理服务器很麻烦， 一般都是用FQ软件来自动发现代理服务器的。<br/>
<img src="media/15038326274764/15038326615494.jpg" alt=""/></p>

<h3 id="toc_3">代理的作用二， 匿名访问</h3>

<p>经常听新闻，说”某某某“在网络上发布帖子，被跨省追缉了。   假如他使用匿名的代理服务器，就不容易暴露自己的身份了。 <br/>
http代理服务器的匿名性是指： HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址， 或cookie,或URI的会话ID）， 从而对远端服务器隐藏原始用户的IP地址以及其他细节。 同时HTTP代理服务器上也不会记录原始用户访问记录的log(否则也会被查到)。</p>

<h3 id="toc_4">代理的作用三， 通过代理上网</h3>

<p>比如局域网不能上网， 只能通过局域网内的一台代理服务器上网。</p>

<h3 id="toc_5">代理的作用四， 通过代理缓存，加快上网速度</h3>

<p>大部分代理服务器都具有缓存的功能，就好像一个大的cache， 它有很大的存储空间，它不断将新取得数据存储到它本地的存储器上， 如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传给用户的浏览器，这样就能显著提高浏览速度。</p>

<h3 id="toc_6">代理的作用五：儿童过滤器</h3>

<p>很多教育机构， 会利用过滤器代理来阻止学生访问成人内容。<br/>
<img src="media/15038326274764/15038326688506.jpg" alt=""/></p>

<h3 id="toc_7">代理认证，和407状态码</h3>

<p>代理服务器也可以需要权限认证， HTTP定义了一种名为代理认证（Proxy authentication）的机制。 这种机制可以阻止对内容的请求。<br/>
当浏览器访问需要认证的代理时， 代理服务器会返回407 Authorization Required,告诉浏览器输入用户名和密码。<br/>
<img src="media/15038326274764/15038326738168.jpg" alt=""/></p>

<h3 id="toc_8">使用代理服务器的安全问题</h3>

<p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。</p>

<h3 id="toc_9">如何搭建代理服务器</h3>

<p>可以使用CCproxy, 和Squid 来搭建代理服务器。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (四) 缓存]]></title>
    <link href="weijing24.github.io/15038325535184.html"/>
    <updated>2017-08-27T19:15:53+08:00</updated>
    <id>weijing24.github.io/15038325535184.html</id>
    <content type="html"><![CDATA[
<p>这次继续介绍HTTP协议中的缓存机制。HTTP协议提供了非常强大的缓存机制， 了解这些缓存机制，对提高网站的性能非常有帮助。 本文介绍浏览器和Web服务器之间如何处理&quot;浏览器缓存&quot;，以及控制缓存的http header.</p>

<h3 id="toc_0">缓存的概念</h3>

<p>缓存这个东西真的是无处不在， 有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。<br/>
http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。<br/>
http缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。</p>

<h3 id="toc_1">缓存的好处</h3>

<p>缓存的好处是显而易见的， 好处有，<br/>
1. 减少了冗余的数据传输，节省了网费。<br/>
2. 减少了服务器的负担， 大大提高了网站的性能<br/>
3. 加快了客户端加载网页的速度</p>

<h3 id="toc_2">Fiddler可以方便地查看缓存的header</h3>

<p>Fiddler中把header都分门别类的放在一起，这样方便查看。<br/>
<img src="media/15038325535184/15038325644897.jpg" alt=""/></p>

<h3 id="toc_3">如何判断缓存新鲜度</h3>

<p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。<br/>
第一种， 浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。<br/>
第二种， 浏览器把缓存文件的ETag, 通过header &quot;If-None-Match&quot;, 来告诉Web服务器。</p>

<h3 id="toc_4">通过最后修改时间, 来判断缓存新鲜度</h3>

<ol>
<li>浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存，  获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。</li>
<li><p>Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本。如下图。<br/>
<img src="media/15038325535184/15038325722769.jpg" alt=""/></p></li>
<li><p>假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。<br/>
<img src="media/15038325535184/15038325788499.jpg" alt=""/></p></li>
</ol>

<p>实例： 打开Fiddler, 然后打开博客园首页。然后F5刷新几次浏览器。 你会看到博客园首页也用了缓存。<br/>
<img src="media/15038325535184/15038325851441.jpg" alt=""/></p>

<h3 id="toc_5">与缓存有关的header</h3>

<p>我们来看看每个header的具体含义。<br/>
Request</p>

<blockquote>
<pre><code>Cache-Control: max-age=0                               以秒为单位
If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT    缓存文件的最后修改时间。
If-None-Match: &quot;0693f67a67cc1:0&quot;                    缓存文件的Etag值
Cache-Control: no-cache                                不使用缓存
Pragma: no-cache                                   不使用缓存
</code></pre>
</blockquote>

<p>Response</p>

<blockquote>
<pre><code>Cache-Control: public             响应被缓存，并且在多用户间共享
Cache-Control: private       响应只能作为私有缓存，不能在用户之间共享
Cache-Control:no-cache       提醒浏览器要从服务器提取文档进行验证
Cache-Control:no-store       绝对禁止缓存（用于机密，敏感文件）
Cache-Control: max-age=60       60秒之后缓存过期（相对时间）
Date: Mon, 19 Nov 2012 08:39:00 GMT     当前response发送的时间
Expires: Mon, 19 Nov 2012 08:40:01 GMT      缓存过期的时间（绝对时间）
Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT    服务器端文件的最后修改时间
ETag: &quot;20b1add7ec1cd1:0&quot;                       服务器端文件的Etag值
</code></pre>
</blockquote>

<p>如果同时存在cache-control和Expires怎么办呢？<br/>
浏览器总是优先使用cache-control，如果没有cache-control才考虑Expires </p>

<h3 id="toc_6">ETag</h3>

<p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。<br/>
ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。<br/>
为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。<br/>
1. 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。<br/>
2. 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。<br/>
3. 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。<br/>
实例， 打开Fiddler, 打开博客园首页。  你可以看到很多图片，或者CSS文件都是用了缓存。 这些都是通过比较ETag的值，来判断文件是否更新了。<br/>
<img src="media/15038325535184/15038325952640.jpg" alt=""/></p>

<h3 id="toc_7">浏览器不使用缓存</h3>

<p>CTRL+F5强制刷新浏览器，或者设置IE。  可以让浏览器不使用缓存。<br/>
1. 浏览器发送Http request, 给Web 服务器， header中带有Cache-Control: no-cache.   明确告诉Web服务器，客户端不使用缓存。 <br/>
2. Web服务器将把最新的文档发送给浏览器客户端.<br/>
实例:<br/>
打开Fiddler, 打开博客园首页， 然后按CTRL+F5强制刷新浏览器，你将看到<br/>
<img src="media/15038325535184/15038326056638.jpg" alt=""/></p>

<p>Pragma: no-cache的作用和Cache-Control: no-cache一模一样。 都是不使用缓存。 <br/>
Pragma: no-cache 是HTTP 1.0中定义的， 所以为了兼容HTTP 1.0. 所以会同时使用Pragma: no-cache和Cache-Control: no-cache</p>

<h3 id="toc_8">直接使用缓存，不去服务器验证</h3>

<p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。<br/>
按F5刷新浏览器， 浏览器会去Web服务器验证缓存。<br/>
如果是在地址栏输入网址然后回车，浏览器会&quot;直接使用有效的缓存&quot;, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图<br/>
<img src="media/15038325535184/15038326137221.jpg" alt=""/></p>

<p>实例： 比较第一次访问博客园主页和第二次博客园主页<br/>
1. 启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。<br/>
2. 按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。发现只有30多个session.<br/>
分析:少了的session是因为firefox直接用了缓存，而没有发http request。<br/>
<img src="media/15038325535184/15038326196474.jpg" alt=""/></p>

<h3 id="toc_9">公有缓存和私有缓存的区别</h3>

<p>Cache-Control: public 指可以公有缓存， 可以是数千名用户共享的。<br/>
Cache-Control: private 指只支持私有缓存， 私有缓存是单个用户专用的。<br/>
<img src="media/15038325535184/15038326252661.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (三) 压缩]]></title>
    <link href="weijing24.github.io/15038324866170.html"/>
    <updated>2017-08-27T19:14:46+08:00</updated>
    <id>weijing24.github.io/15038324866170.html</id>
    <content type="html"><![CDATA[
<p>　　HTTP压缩是指: Web服务器和浏览器之间压缩传输的”文本内容“的方法。 HTTP采用通用的压缩算法，比如gzip来压缩HTML,Javascript, CSS文件。 能大大减少网络传输的数据量，提高了用户显示网页的速度。当然，同时会增加一点点服务器的开销。 本文从HTTP协议的角度，来理解HTTP压缩这个概念。</p>

<h3 id="toc_0">HTTP内容编码和HTTP压缩的区别</h3>

<p>　　HTTP压缩，在HTTP协议中，其实是内容编码的一种。<br/>
　　在http协议中，可以对内容（也就是body部分）进行编码， 可以采用gzip这样的编码。 从而达到压缩的目的。 也可以使用其他的编码把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。<br/>
　　所以我们说HTTP压缩，其实就是HTTP内容编码的一种。 所以大家不要把HTTP压缩和HTTP内容编码两个概念混淆了。</p>

<h3 id="toc_1">HTTP压缩的过程</h3>

<ol>
<li>浏览器发送Http request 给Web服务器,  request 中有Accept-Encoding: gzip, deflate。 (告诉服务器， 浏览器支持gzip压缩)</li>
<li>Web服务器接到request后， 生成原始的Response, 其中有原始的Content-Type和Content-Length。</li>
<li>Web服务器通过Gzip，来对Response进行编码， 编码后header中有Content-Type和Content-Length(压缩后的大小)， 并且增加了Content-Encoding:gzip.  然后把Response发送给浏览器。</li>
<li>浏览器接到Response后，根据Content-Encoding:gzip来对Response 进行解码。 获取到原始response后， 然后显示出网页。
如下图:
<img src="media/15038324866170/15038325106127.jpg" alt=""/></li>
</ol>

<h3 id="toc_2">实例：Fiddler观察HTTP压缩</h3>

<p>　　眼见为实， 我们看一个实际的例子， 我发现博客园就使用了gzip压缩。使用Fiddler可以清楚地看到。<br/><br/>
<img src="media/15038324866170/15038325174079.jpg" alt=""/><br/>
<img src="media/15038324866170/15038325225567.jpg" alt=""/><br/>
　　在Fiddler中，每次都要手动去decode. 太麻烦。  点击工具栏上的&quot;Decode&quot;按钮，就可以自动decode了。</p>

<h3 id="toc_3">内容编码类型</h3>

<p>　　HTTP定义了一些标准的内容编码类型，并允许用扩展的形式添加更多的编码。<br/>
　　Content-Encoding header 就用这些标准化的代号来说明编码时使用的算法<br/>
　　Content-Encoding值</p>

<p>gzip　　表明实体采用GNU zip编码<br/>
compress 表明实体采用Unix的文件压缩程序<br/>
deflate　　表明实体是用zlib的格式压缩的<br/>
identity　　表明没有对实体进行编码。当没有Content-Encoding header时， 就默认为这种情况<br/>
gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。 其中gzip通常效率最高， 使用最为广泛。</p>

<h3 id="toc_4">压缩的好处</h3>

<p>http压缩对纯文本可以压缩至原内容的40%, 从而节省了60%的数据传输。<br/>
 实例： 博客园首页压缩前是：46124 bytes. 压缩后是：16368bytes.     只有原先的35%。  节省了65%的数据传输，从而大大提高了性能<br/>
 有图为证。<br/>
<img src="media/15038324866170/15038325318575.jpg" alt=""/><br/>
<img src="media/15038324866170/15038325383335.jpg" alt=""/></p>

<h3 id="toc_5">Gzip的缺点</h3>

<p>JPEG这类文件用gzip压缩的不够好。</p>

<h3 id="toc_6">Gzip是如何压缩的</h3>

<p>简单来说， Gzip压缩是在一个文本文件中找出类似的字符串， 并临时替换他们，使整个文件变小。这种形式的压缩对Web来说非常适合， 因为HTML和CSS文件通常包含大量的重复的字符串，例如空格，标签。</p>

<h3 id="toc_7">HTTP Response能压缩，HTTP Request也是可以压缩的</h3>

<p>浏览器是不会对Request压缩的。 但是 一些HTTP程序在发送Request时，会对其进行编码。 如下图。<br/>
<img src="media/15038324866170/15038325444320.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (二) 基本认证]]></title>
    <link href="weijing24.github.io/15038324138209.html"/>
    <updated>2017-08-27T19:13:33+08:00</updated>
    <id>weijing24.github.io/15038324138209.html</id>
    <content type="html"><![CDATA[
<p>　　http协议是无状态的， 浏览器和web服务器之间可以通过cookie来身份识别。 桌面应用程序(比如新浪桌面客户端， skydrive客户端)跟Web服务器之间是如何身份识别呢？</p>

<h3 id="toc_0">什么是HTTP基本认证</h3>

<p>　　桌面应用程序也通过HTTP协议跟Web服务器交互， 桌面应用程序一般不会使用cookie, 而是把 &quot;用户名+冒号+密码&quot;用BASE64编码的字符串放在http request 中的header Authorization中发送给服务端， 这种方式叫HTTP基本认证(Basic Authentication)<br/>
　　当浏览器访问使用基本认证的网站的时候， 浏览器会提示你输入用户名和密码，如下图<br/>
<img src="media/15038324138209/15038324448462.jpg" alt=""/><br/>
假如用户名密码错误的话， 服务器会返回401 如下图<br/>
<img src="media/15038324138209/15038324522213.jpg" alt=""/></p>

<h3 id="toc_1">HTTP基本认证的过程</h3>

<p>第一步:  客户端发送http request 给服务器， <br/>
第二步:  因为request中没有包含Authorization header,  服务器会返回一个401 Unauthozied 给客户端，并且在Response 的 header &quot;WWW-Authenticate&quot; 中添加信息。<br/>
<img src="media/15038324138209/15038324599743.jpg" alt=""/><br/>
第三步：客户端把用户名和密码用BASE64编码后，放在Authorization header中发送给服务器， 认证成功。<br/>
第四步：服务器将Authorization header中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端<br/>
<img src="media/15038324138209/15038324692971.jpg" alt=""/><br/>
使用Fiddler Inspectors 下的Auth 选项卡，可以很方便的看到用户名和密码:<br/>
<img src="media/15038324138209/15038324745573.jpg" alt=""/></p>

<h3 id="toc_2">HTTP基本认证的优点</h3>

<p>HTTP基本认证，简单明了。Rest API 就是经常使用基本认证的</p>

<h3 id="toc_3">每次都要进行认证</h3>

<p>http协议是无状态的， 同一个客户端对 服务器的每个请求都要求认证</p>

<h3 id="toc_4">HTTP基本认证和HTTPS</h3>

<p>把 &quot;用户名+冒号+密码&quot; 用BASE64编码后的string虽然用肉眼看不出来， 但用程序很容易解密，上图可以看到Fiddler就直接给解密了。 所以这样的http request 在网络上，如果用HTTP传输是很不安全的。 一般都是会用HTTPS传输, HTTPS是加密的, 所以比较安全.</p>

<h3 id="toc_5">HTTP OAuth认证</h3>

<p>OAuth 对于Http来说，就是放在Authorization header中的不是用户名密码， 而是一个token.<br/>
微软的Skydrive 就是使用这样的方式， 如下图<br/>
<img src="media/15038324138209/15038324813415.jpg" alt=""/></p>

<h3 id="toc_6">其他认证</h3>

<p>除了基本认证(Basic Authentication), 还有摘要认证 digest authentication, WSSE(WS-Security)认证</p>

<h3 id="toc_7">客户端的使用</h3>

<p>客户端如果要跟“使用基本认证的网站”交互。 非常很简单，把用户名密码 加在Authorization header中就可以了。</p>

<p>C#</p>

<blockquote>
<pre><code>string url = &quot;https://testsite&quot;;
HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
NetworkCredential nc = new NetworkCredential(&quot;username&quot;, &quot;password&quot;);
req.Credentials = nc;
</code></pre>
</blockquote>

<p>Linux下的curl</p>

<blockquote>
<pre><code>curl -u username:password https://testsite/
</code></pre>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议 (一) HTTP协议详解]]></title>
    <link href="weijing24.github.io/15038322654511.html"/>
    <updated>2017-08-27T19:11:05+08:00</updated>
    <id>weijing24.github.io/15038322654511.html</id>
    <content type="html"><![CDATA[
<p>　　当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。使用Fiddler工具非常方便地捕获HTTP Request和HTTP Response,  关于Fiddler工具的用法，请看我另一篇博客[Fiddler 教程]</p>

<h3 id="toc_0">什么是HTTP协议</h3>

<p>　　协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。目前我们使用的是HTTP/1.1 版本</p>

<h3 id="toc_1">Web服务器，浏览器,代理服务器</h3>

<p>　　当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？<br/>
　　实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示<br/>
<img src="media/15038322654511/15038322775952.jpg" alt=""/><br/>
　　我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示<br/>
<img src="media/15038322654511/15038322823911.jpg" alt=""/><br/>
　　代理服务器就是网络信息的中转站，有什么功能呢？<br/>
　　1. 提高访问速度， 大多数的代理服务器都有缓存功能。<br/>
　　2. 突破限制，也就是FQ了<br/>
　　3. 隐藏身份。</p>

<h3 id="toc_2">URL详解</h3>

<p>　　URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下<br/>
　　<code>schema://host[:port#]/path/.../[?query-string][#anchor]</code>　　</p>

<table>
<thead>
<tr>
<th>scheme</th>
<th>指定底层使用的协议(例如：http, https, ftp)</th>
</tr>
</thead>

<tbody>
<tr>
<td>host</td>
<td>HTTP服务器的IP地址或者域名</td>
</tr>
<tr>
<td>port#</td>
<td>HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明</td>
</tr>
<tr>
<td>path</td>
<td>访问资源的路径</td>
</tr>
<tr>
<td>query-string </td>
<td>发送给http服务器的数据</td>
</tr>
<tr>
<td>anchor</td>
<td>锚</td>
</tr>
</tbody>
</table>

<p>URL 的一个例子</p>

<blockquote>
<pre><code>http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff
Schema:                 http
host:                   www.mywebsite.com
path:                   /sj/test/test.aspx
Query String:           name=sviergn&amp;x=true
Anchor:                 stuff
</code></pre>
</blockquote>

<h3 id="toc_3">HTTP协议是无状态的</h3>

<p>　　http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p>

<h3 id="toc_4">打开一个网页需要浏览器发送很多次Request</h3>

<ol>
<li>当你在浏览器输入URL <a href="http://www.cnblogs.com">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器.</li>
<li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</li>
<li>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li>
<li>等所有的文件都下载成功后。 网页就被显示出来了。</li>
</ol>

<h3 id="toc_5">HTTP消息的结构</h3>

<p>　　先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图<br/>
<img src="media/15038322654511/15038322919074.jpg" alt=""/><br/>
　　第一行中的Method表示请求方法,比如&quot;POST&quot;,&quot;GET&quot;,Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号,当使用的是&quot;GET&quot;方法的时候，body是为空的.比如我们打开博客园首页的request 如下</p>

<blockquote>
<pre><code>GET http://www.cnblogs.com/ HTTP/1.1
Host: www.cnblogs.com
</code></pre>
</blockquote>

<p>　　抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们  今天用Fiddler，实际的看看Request和Response.<br/>
　　下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，如下图<br/>
<img src="media/15038322654511/15038322975053.jpg" alt=""/><br/>
　　我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图<br/>
<img src="media/15038322654511/15038323032015.jpg" alt=""/><br/>
　　HTTP/version-number表示HTTP协议的版本号<br/>
　　我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息,如下图<br/>
<img src="media/15038322654511/15038323095467.jpg" alt=""/></p>

<h3 id="toc_6">Get和Post方法的区别</h3>

<p>　　Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.<br/>
　　我们看看GET和POST的区别<br/>
　　1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.<br/>
　　2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.<br/>
　　3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。<br/>
　　4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>

<h3 id="toc_7">状态码</h3>

<p>　　Response消息中的第一行叫做状态行,由HTTP协议版本号,状态码,状态消息三部分组成。<br/>
　　状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.<br/>
　　HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>

<table>
<thead>
<tr>
<th>1XX</th>
<th>提示信息 - 表示请求已被成功接收，继续处理</th>
</tr>
</thead>

<tbody>
<tr>
<td>2XX</td>
<td>成功 - 表示请求已被成功接收，理解，接受</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向 - 要完成请求必须进行更进一步的处理</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误 - 请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器端错误 - 服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>

<p>看看一些常见的状态码<br/>
200 OK<br/>
　　最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端<br/>
如下图， 打开博客园首页<br/>
<img src="media/15038322654511/15038323215987.jpg" alt=""/></p>

<p>302 Found<br/>
　　重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request<br/>
　　例如在IE中输入， <a href="http://www.google.com">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.<br/>
<img src="media/15038322654511/15038323275941.jpg" alt=""/></p>

<p>304 Not Modified<br/>
　　代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304<br/>
<img src="media/15038322654511/15038323334462.jpg" alt=""/><br/>
　　提示：如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p>

<p>400 Bad Request  客户端请求与语法错误，不能被服务器所理解<br/>
403 Forbidden 服务器收到请求，但是拒绝提供服务<br/>
404 Not Found<br/>
　　请求资源不存在（输错了URL）比如在IE中输入一个错误的URL，<a href="http://www.cnblogs.com/tesdf.aspx">http://www.cnblogs.com/tesdf.aspx</a><br/>
<img src="media/15038322654511/15038323393467.jpg" alt=""/></p>

<p>500 Internal Server Error 服务器发生了不可预期的错误</p>

<p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>

<h3 id="toc_8">HTTP Request header</h3>

<p>　　使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers  如下图所示.<br/>
<img src="media/15038322654511/15038323524077.jpg" alt=""/><br/>
　　header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>

<h5 id="toc_9">Cache头域</h5>

<p>If-Modified-Since<br/>
　　作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.<br/>
　　例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT,实例如下<br/>
<img src="media/15038322654511/15038323649392.jpg" alt=""/></p>

<p>If-None-Match<br/>
　　作用:If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新),将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.使用这样的机制将提高网站的性能<br/>
　　例如: If-None-Match: &quot;03f2b33c0bfcc1:0&quot;,实例如下图<br/>
<img src="media/15038322654511/15038323725472.jpg" alt=""/></p>

<p>Pragma<br/>
　　作用：防止页面被缓存，在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样.Pargma只有一个用法， 例如：Pragma: no-cache.注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>

<p>Cache-Control<br/>
　　作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下<br/>
　　Cache-Control:Public   可以被任何缓存所缓存（）<br/>
　　Cache-Control:Private     内容只缓存到私有缓存中<br/>
　　Cache-Control:no-cache  所有内容都不会被缓存<br/>
　　还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p>

<h5 id="toc_10">Client头域</h5>

<p>Accept<br/>
　　作用：浏览器端可以接受的媒体类型,<br/>
　　例如：Accept: text/html代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)<br/>
通配符 * 代表任意类型<br/>
　　例如Accept: */*  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p>

<p>Accept-Encoding：<br/>
　　作用：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;<br/>
　　例如：Accept-Encoding: gzip, deflate</p>

<p>Accept-Language<br/>
　　作用： 浏览器申明自己接收的语言。 <br/>
　　语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如： Accept-Language: en-us</p>

<p>User-Agent<br/>
　　作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.<br/>
　　我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。<br/>
　　例如：User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>

<p>Accept-Charset<br/>
　　作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p>

<h5 id="toc_11">Cookie/Login头域</h5>

<p>Cookie:<br/>
作用：最重要的header,将cookie的值发送给HTTP服务器<br/>
Entity头域<br/>
Content-Length<br/>
作用：发送给HTTP服务器数据的长度。<br/>
例如：Content-Length: 38</p>

<p>Content-Type<br/>
作用：<br/>
例如：Content-Type: application/x-www-form-urlencoded</p>

<h5 id="toc_12">Miscellaneous 头域</h5>

<p>Referer:<br/>
作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。<br/>
例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>

<h5 id="toc_13">Transport 头域</h5>

<p>Connection<br/>
例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br/>
例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>

<p>Host（发送请求时，该报头域是必需的）<br/>
作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的<br/>
例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a><br/>
浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br/>
Host：<a href="http://www.guet.edu.cn">http://www.guet.edu.cn</a><br/>
此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>

<h3 id="toc_14">HTTP Response header</h3>

<p>　　同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers  如下图所示<br/>
<img src="media/15038322654511/15038323873588.jpg" alt=""/></p>

<h5 id="toc_15">Cache头域</h5>

<p>Date<br/>
作用:  生成消息的具体时间和日期<br/>
例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT <br/>
Expires<br/>
作用: 浏览器会在指定过期时间内使用本地缓存<br/>
例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT<br/>
Vary<br/>
作用：<br/>
例如: Vary: Accept-Encoding</p>

<h5 id="toc_16">Cookie/Login 头域</h5>

<p>P3P<br/>
作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题<br/>
例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP CORSet-Cookie<br/>
作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.<br/>
例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com<br/>
<img src="media/15038322654511/15038323945138.jpg" alt=""/></p>

<h5 id="toc_17">Entity头域</h5>

<p>ETag<br/>
作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）<br/>
例如: ETag: &quot;03f2b33c0bfcc1:0&quot;</p>

<p>Last-Modified:<br/>
作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）<br/>
例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>

<p>Content-Type<br/>
作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,<br/>
例如:<br/>
Content-Type: text/html; charset=utf-8<br/>
Content-Type:text/html;charset=GB2312<br/>
Content-Type: image/jpeg</p>

<p>Content-Length<br/>
指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。<br/>
例如: Content-Length: 19847</p>

<p>Content-Encoding<br/>
WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。<br/>
例如：Content-Encoding：gzip</p>

<p>Content-Language<br/>
作用： WEB服务器告诉浏览器自己响应的对象的语言者<br/>
例如： Content-Language:da</p>

<h5 id="toc_18">Miscellaneous 头域</h5>

<p>Server:<br/>
作用：指明HTTP服务器的软件信息<br/>
例如:Server: Microsoft-IIS/7.5</p>

<p>X-AspNet-Version:<br/>
作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本<br/>
例如: X-AspNet-Version: 4.0.30319</p>

<p>X-Powered-By:<br/>
作用：表示网站是用什么技术开发的<br/>
例如： X-Powered-By: ASP.NET</p>

<h5 id="toc_19">Transport头域</h5>

<p>Connection<br/>
例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br/>
例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>

<h5 id="toc_20">Location头域</h5>

<p>Location<br/>
作用： 用于重定向一个新的位置, 包含新的URL地址<br/>
 实例请看304状态实例</p>

<h3 id="toc_21">HTTP协议是无状态的和Connection: keep-alive的区别</h3>

<p>　　无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系<br/>
HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）<br/>
　　从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br/>
　　Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[i节点，容易被人遗忘的节点]]></title>
    <link href="weijing24.github.io/15038322315997.html"/>
    <updated>2017-08-27T19:10:31+08:00</updated>
    <id>weijing24.github.io/15038322315997.html</id>
    <content type="html"><![CDATA[
<p>　　部分内容转自<a href="http://blog.sina.com.cn/s/blog_6c9d65a10101byi6.html">点击打开链接</a> <a href="http://blog.csdn.net/ancient_wind/article/details/7938053">点击打开链接</a><br/>
　　前段时间做了RHCE的一道题，是iSCSi的，后来在挂载的时候说是磁盘被占用。当时资料找了很多结果还是没有找到解决方法。反倒是发现了这个inode，也是关于被占用的，只不过这个是空间被占用。<br/>
　　可能有人会碰到一种情况就是明明磁盘还有很大的空间，但是不能创建文件了。这其实是inode搞得鬼。讲到inode就不得不先讲文件系统。<br/>
　　文件系统创建结束，分区分为超级块、inode表和数据区三个部分。超级块存放文件系统本身的结构信息. 比如, 超级块记录了每个区域的大小, 超级块也存放未被使用的磁盘块的信息.  inode表存放着文件的一些属性,如文件的大小, 文件所有者, 和创建时间等, 所有i节点都有相同的大小, 并且inode表是这些结构的一个列表, 文件系统中每个文件在该表中都有一个inode, 需要注意的是, inode并不存放文件的名字. 数据区保存了文件的实际的内容. 磁盘上所有块的大小都一样, 这个跟文件系统的块大小是可以不一样的, 文件系统的块大小可以在格式化的时候指定, 这也就是为什么众多SSD玩家买了SSD硬盘之后要4K对齐的最终原因了, 因为传统的格式化的默认的文件系统的块大小跟SSD这种新型的存储设备的块大小是不一样的(传统的是512字节, 而SSD是4096字节), 如果文件系统的块是512而SSD的默认块是4096, 那么读取文件的时候效率就是个问题了, 因为本来读取一次就可以的数据需要读取多次.  如果如果文件包含了超过一个块的内容, 则文件内容会存放在多个数据区的块中. <br/>
　　我们知道在linux下一切都是文件：文件是文件，目录是文件，甚至设置也是文件。那么目录就没有inode了吗？其实目录可以看成是一群inode 的集合。目录里面并没有存储文件本身，而是文件名和文件的inode号。<br/>
　　那么回到我们的主题。当你创建一个文件的时候，系统就自动为你的文件申请了inode。inode是会消耗磁盘空间的。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode表的大小就会达到128MB，占整块硬盘的12.8%。当你创建了N多个文件并且每个文件很小的时候，可能你的inode已经用光了，但是磁盘仍有剩余。这就是为什么有人遇到磁盘有剩余但创建文件仍然提示磁盘空间不足的原因<br/>
提供一些查看inode的命令：</p>

<p>查看文件系统的inode总数和使用情况</p>

<blockquote>
<p>df -i</p>
</blockquote>

<p>查看文件的inode号</p>

<blockquote>
<p>ls -i ×××</p>
</blockquote>

<p>查看文件的详细信息</p>

<blockquote>
<p>stat ×××</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[libc.so.6被删后导致系统无法使用的原因及解决方法]]></title>
    <link href="weijing24.github.io/15038321032705.html"/>
    <updated>2017-08-27T19:08:23+08:00</updated>
    <id>weijing24.github.io/15038321032705.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">记一次升级glibc库发生的错误</h2>

<p>　　今天给glibc库升级，发生了一件让我吓出一声汗的事情，我把动态库中的libc.so.6给删了，瞬间所有的非系统命令都无法使用，使用就报错<br/>
<img src="media/15038321032705/15038321195076.jpg" alt=""/><br/>
<img src="media/15038321032705/15038321236181.jpg" alt=""/><br/>
　　当时就吓尿了，生产环境被我玩坏了，怎么破。后来查原因才知道很多命令都依赖glibc，我把它的软链接删了系统找不到此库，那肯定玩完。<br/>
　　整个事情完整的经过是这样的：同事需要升级glibc库，于是此任务落到了我手中，当时没有想到那么多，以为和一般的软件一样随手一升就行了，后来发现有点复杂的，下了个2.9的版本（忽略下图的2.6，后来改成2.9了，2.6也一样，所有的glibc都会有这个问题），按照configure、make、make install三部曲来，结果第一步就失败了<br/>
<img src="media/15038321032705/15038321286301.jpg" alt=""/><br/>
　　后来才知道需要在glibc的同级目录下创建一个glibc-build目录，在glibc-build目录中执行configure，具体步骤参见<a href="http://blog.csdn.net/officercat/article/details/39520227">http://blog.csdn.net/officercat/article/details/39520227</a><br/>
其实按照这个链接操作理论上是不会发生我这样坑爹的事情的，但是我作死了，在--prefix的时候没有使用/usr，而是安装在了自定义的目录中，当时想的是怕装在usr中会破坏现有环境（事实上glibc都要升级了还留着老版本干嘛？）<br/>
　　于是在我安装到自定义目录后，我开始将安装到自定义目录中的glibc动态库一个个拷贝到/lib64中（有的系统是/lib），就在这里我将libc.so.6删除了，准备重做一个软链接到新的glibc库中，删除之后就出现了文中开头的那一幕。我在贴个图就能明白为什么会发生这种情况了<br/>
<img src="media/15038321032705/15038321336502.jpg" alt=""/></p>

<blockquote>
<pre><code>不仅仅是iconv，基本上非系统命令都有这一条 libc.so.6 =&gt; /lib64/libc.so.6 ,因此libc.so.6至关重要，绝对不能删，不能改名，能不能覆盖就不知道了，想作死的可以试试
</code></pre>
</blockquote>

<p>　　好了，死做完了，说说怎么解决问题吧。既然命令无法寻址到软连接，那么直接命令行给他就是了，网上看到了两种方法</p>

<p>1、ldconfig -l -v /lib64/libc-2.5.so<br/>
这里写的<strong>libc库必须是原来使用的而不是你更新过的</strong></p>

<p>2、LD_PRELOAD=/lib64/libc-2.5.so ln -s /lib64/libc-2.5.so /lib64/libc.so.6</p>

<blockquote>
<pre><code>LD_PRELOAD允许你定义在程序运行前优先加载的动态链接库,因此在使用ln前就加载了lib库，而不是等到使用ln时加载，这样就能临时使用命令了
</code></pre>
</blockquote>

<p>　　不仅仅是ln，只要加了LD_PRELOAD=/lib64/libc-2.5.so，<strong>后面可以跟一切因为libc.so.6被删不能用的命令。</strong><br/>
　　<br/>
　　我使用的是第二种方法</p>

<p>　　然后命令又能用了，然后我就老老实实的按照之前给出的连接安装到/usr，可以看到现在libc.so.6是软连接到libc-2.9.so的，最开始是连接到libc-2.5.so的。<br/>
<img src="media/15038321032705/15038321569794.jpg" alt=""/></p>

<p>　　使用strings命令查看，可以看到已经有2.9了<br/>
<img src="media/15038321032705/15038321609485.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下nginx模块开发入门]]></title>
    <link href="weijing24.github.io/15038318990451.html"/>
    <updated>2017-08-27T19:04:59+08:00</updated>
    <id>weijing24.github.io/15038318990451.html</id>
    <content type="html"><![CDATA[
<p>　　本文模块编写参考<a href="http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html">http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html</a><br/>
　　之前讲了nginx的安装,算是对nginx有了最初步的了解,在配置完之后,我们就可以进行简单的nginx模块开发了.下面本文展示一个简单的Nginx模块开发全过程，我们开发一个叫echo的handler模块，这个模块功能非常简单，它接收“echo”指令，指令可指定一个字符串参数，模块会输出这个字符串作为HTTP响应。例如，对nginx.conf做如下配置：</p>

<blockquote>
<pre><code>location /echo {
    echo &quot;hello&quot;;
}
</code></pre>
</blockquote>

<p>则访问http://localhost/echo时会输出hello nginx。<br/>
要实现这个功能需要三步：<strong>1、读入配置文件中echo指令及其参数；2、进行HTTP包装（添加HTTP头等工作）；3、将结果返回给客户端。</strong>下面本文将分部介绍整个模块的开发过程。</p>

<h3 id="toc_0">定义模块配置结构</h3>

<p>　　首先我们需要一个结构用于存储从配置文件中读进来的相关指令参数，即模块配置信息结构。根据Nginx模块开发规则，这个结构的命名规则为ngx_http_[module-name]_[main|srv|loc]_conf_t。其中main、srv和loc分别用于表示同一模块在三层block中的配置信息。这里我们的echo模块只需要运行在loc层级下，需要存储一个字符串参数，因此我们可以定义如下的模块配置：</p>

<blockquote>
<pre><code>typedef struct {
    ngx_str_t ed;
} ngx_http_echo_loc_conf_t;
</code></pre>
</blockquote>

<p>　　其中字段ed用于存储echo指令指定的需要输出的字符串。注意这里ed的类型，在Nginx模块开发中使用ngx_str_t类型表示字符串，这个类型定义在core/ngx_string中：</p>

<blockquote>
<pre><code>typedef struct {
    size_t len;
    u_char *data;
} ngx_str_t;
</code></pre>
</blockquote>

<p>　　其中两个字段分别表示字符串的长度和数据起始地址。注意在Nginx源代码中对数据类型进行了别称定义，如ngx_int_t为intptr_t的别称，为了保持一致，在开发Nginx模块时也应该使用这些Nginx源码定义的类型而不要使用C原生类型。除了ngx_str_t外，其它三个常用的nginx type分别为：</p>

<blockquote>
<pre><code>typedef intptr_t ngx_int_t;
typedef uintptr_t ngx_uint_t;
typedef intptr_t ngx_flag_t;
</code></pre>
</blockquote>

<p>　　具体定义请参看core/ngx_config.h。关于intptr_t和uintptr_t请参考C99中的stdint.h或<a href="http://linux.die.net/man/3/intptr_t%E3%80%82">http://linux.die.net/man/3/intptr_t。</a></p>

<h3 id="toc_1">定义指令</h3>

<p>　　一个Nginx模块往往接收一至多个指令，echo模块接收一个指令“echo”。Nginx模块使用一个ngx_command_t数组表示模块所能接收的所有模块，其中每一个元素表示一个条指令。ngx_command_t是ngx_command_s的一个别称（Nginx习惯于使用“_s”后缀命名结构体，然后typedef一个同名“_t”后缀名称作为此结构体的类型名），ngx_command_s定义在core/ngx_config_file.h中：</p>

<blockquote>
<pre><code>struct ngx_command_s {
    ngx_str_t name;
    ngx_uint_t type;
    char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    ngx_uint_t conf;
    ngx_uint_t offset;
    void *post;
};
</code></pre>
</blockquote>

<p>　　其中name是词条指令的名称，type使用掩码标志位方式配置指令参数，相关可用type定义在core/ngx_config_file.h中：</p>

<blockquote>
<pre><code>#define NGX_CONF_NOARGS 0x00000001
#define NGX_CONF_TAKE1 0x00000002
#define NGX_CONF_TAKE2 0x00000004
#define NGX_CONF_TAKE3 0x00000008
#define NGX_CONF_TAKE4 0x00000010
#define NGX_CONF_TAKE5 0x00000020
#define NGX_CONF_TAKE6 0x00000040
#define NGX_CONF_TAKE7 0x00000080
#define NGX_CONF_MAX_ARGS 8
#define NGX_CONF_TAKE12 (NGX_CONF_TAKE1|NGX_CONF_TAKE2)
#define NGX_CONF_TAKE13 (NGX_CONF_TAKE1|NGX_CONF_TAKE3)
#define NGX_CONF_TAKE23 (NGX_CONF_TAKE2|NGX_CONF_TAKE3)
#define NGX_CONF_TAKE123 (NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3)
#define NGX_CONF_TAKE1234 (NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3|NGX_CONF_TAKE4)
#define NGX_CONF_ARGS_NUMBER 0x000000ff
#define NGX_CONF_BLOCK 0x00000100
#define NGX_CONF_FLAG 0x00000200
#define NGX_CONF_ANY 0x00000400
#define NGX_CONF_1MORE 0x00000800
#define NGX_CONF_2MORE 0x00001000
#define NGX_CONF_MULTI 0x00002000
</code></pre>
</blockquote>

<p>　　其中NGX_CONF_NOARGS表示此指令不接受参数，NGX_CON F_TAKE1-7表示精确接收1-7个，NGX_CONF_TAKE12表示接受1或2个参数，NGX_CONF_1MORE表示至少一个参数，NGX_CONF_FLAG表示接受“on|off”……<br/>
　　set是一个函数指针，用于指定一个参数转化函数，这个函数一般是将配置文件中相关指令的参数转化成需要的格式并存入配置结构体。Nginx预定义了一些转换函数，可以方便我们调用，这些函数定义在core/ngx_conf_file.h中，一般以“_slot”结尾，例如ngx_conf_set_flag_slot将“on或off”转换为“1或0”，再如ngx_conf_set_str_slot将裸字符串转化为ngx_str_t。<br/>
　　conf用于指定Nginx相应配置文件内存其实地址，一般可以通过内置常量指定，如NGX_HTTP_LOC_CONF_OFFSET，offset指定此条指令的参数的偏移量。<br/>
　　下面是echo模块的指令定义：</p>

<blockquote>
<pre><code>static ngx_command_t ngx_http_echo_commands[] = {
    {   ngx_string(&quot;echo&quot;),
        NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
        ngx_http_echo,
        NGX_HTTP_LOC_CONF_OFFSET,
        offsetof(ngx_http_echo_loc_conf_t, ed),
        NULL 
    },
    ngx_null_command
};
</code></pre>
</blockquote>

<p>　　指令数组的命名规则为ngx_http_[module-name]_commands，注意数组最后一个元素要是ngx_null_command结束。<br/>
　　参数转化函数的代码为：</p>

<blockquote>
<pre><code>static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf){
    ngx_http_core_loc_conf_t *clcf;
    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_echo_handler;
    ngx_conf_set_str_slot(cf,cmd,conf);
    return NGX_CONF_OK;
}
</code></pre>

<p>　　这个函数除了调用ngx_conf_set_str_slot转化echo指令的参数外，还将修改了核心模块配置（也就是这个location的配置），将其handler替换为我们编写的handler：ngx_http_echo_handler。这样就屏蔽了此location的默认handler，使用ngx_http_echo_handler产生HTTP响应。</p>
</blockquote>

<h3 id="toc_2">创建合并配置信息</h3>

<p>　　下一步是定义模块Context。这里首先需要定义一个ngx_http_module_t类型的结构体变量，命名规则为ngx_http_[module-name]_module_ctx，这个结构主要用于定义各个Hook函数。下面是echo模块的context结构：</p>

<blockquote>
<pre><code>static ngx_http_module_t ngx_http_echo_module_ctx = {
    NULL, /* preconfiguration */
    NULL, /* postconfiguration */
    NULL, /* create main configuration */
    NULL, /* init main configuration */
    NULL, /* create server configuration */
    NULL, /* merge server configuration */
    ngx_http_echo_create_loc_conf, /* create location configration */
    ngx_http_echo_merge_loc_conf /* merge location configration */
};
</code></pre>
</blockquote>

<p>　　可以看到一共有8个Hook注入点，分别会在不同时刻被Nginx调用，由于我们的模块仅仅用于location域，这里将不需要的注入点设为NULL即可。其中create_loc_conf用于初始化一个配置结构体，如为配置结构体分配内存等工作；merge_loc_conf用于将其父block的配置信息合并到此结构体中，也就是实现配置的继承。这两个函数会被Nginx自动调用。注意这里的命名规则：ngx_http_[module-name]_[create|merge]_[main|srv|loc]_conf。<br/>
　　下面是echo模块这个两个函数的代码：</p>

<blockquote>
<pre><code>static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf){
    ngx_http_echo_loc_conf_t *conf;
    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_echo_loc_conf_t));
    if (conf == NULL) {
        return NGX_CONF_ERROR;
    }
    conf-&gt;ed.len = 0;
    conf-&gt;ed.data = NULL;
    return conf;
}
static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child){
    ngx_http_echo_loc_conf_t *prev = parent;
    ngx_http_echo_loc_conf_t *conf = child;
    ngx_conf_merge_str_value(conf-&gt;ed, prev-&gt;ed, &quot;&quot;);
    return NGX_CONF_OK;
}
</code></pre>
</blockquote>

<p>　　其中ngx_pcalloc用于在Nginx内存池中分配一块空间，是pcalloc的一个包装。使用ngx_pcalloc分配的内存空间不必手工free，Nginx会自行管理，在适当是否释放。<br/>
　　create_loc_conf新建一个ngx_http_echo_loc_conf_t，分配内存，并初始化其中的数据，然后返回这个结构的指针；merge_loc_conf将父block域的配置信息合并到create_loc_conf新建的配置结构体中。<br/>
　　其中ngx_conf_merge_str_value不是一个函数，而是一个宏，其定义在core/ngx_conf_file.h中：</p>

<blockquote>
<pre><code>#define ngx_conf_merge_str_value(conf, prev, default)
if (conf.data == NULL) {
    if (prev.data) {
        conf.len = prev.len;
        conf.data = prev.data;
    }else{
        conf.len = sizeof(default) - 1;
        conf.data = (u_char *) default;
    }
}
</code></pre>
</blockquote>

<p>　　同时可以看到，core/ngx_conf_file.h还定义了很多merge value的宏用于merge各种数据。它们的行为比较相似：使用prev填充conf，如果prev的数据为空则使用default填充。</p>

<h3 id="toc_3">编写Handler</h3>

<p>下面的工作是编写handler。handler可以说是模块中真正干活的代码，它主要有以下四项职责：</p>

<ul>
<li>读入模块配置。</li>
<li>处理功能业务。</li>
<li>产生HTTP header。</li>
<li>产生HTTP body。</li>
</ul>

<p>　　下面先贴出echo模块的代码，然后通过分析代码的方式介绍如何实现这四步。这一块的代码比较复杂：</p>

<blockquote>
<pre><code>static ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r){
    ngx_int_t rc;
    ngx_buf_t *b;
    ngx_chain_t out;
    ngx_http_echo_loc_conf_t *elcf;
    elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
    if(!(r-&gt;method &amp; (NGX_HTTP_HEAD|NGX_HTTP_GET|NGX_HTTP_POST))){
        return NGX_HTTP_NOT_ALLOWED;
    }
    r-&gt;headers_out.content_type.len = sizeof(&quot;text/html&quot;) - 1;
    r-&gt;headers_out.content_type.data = (u_char *) &quot;text/html&quot;;
    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = elcf-&gt;ed.len;
    if(r-&gt;method == NGX_HTTP_HEAD){
        rc = ngx_http_send_header(r);
        if(rc != NGX_OK){
            return rc;
        }
    }
    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if(b == NULL){
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;Failed to allocate response buffer.&quot;);
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }
    out.buf = b;
    out.next = NULL;
    b-&gt;pos = elcf-&gt;ed.data;
    b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len);
    b-&gt;memory = 1;
    b-&gt;last_buf = 1;
    rc = ngx_http_send_header(r);
    if(rc != NGX_OK){
        return rc;
    }
    return ngx_http_output_filter(r, &amp;out);
}   
</code></pre>
</blockquote>

<p>　　handler会接收一个ngx_http_request_t指针类型的参数，这个参数指向一个ngx_http_request_t结构体，此结构体存储了这次HTTP请求的一些信息，这个结构定义在http/ngx_http_request.h中：</p>

<blockquote>
<pre><code>struct ngx_http_request_s {
    uint32_t signature; /* &quot;HTTP&quot; */
    ngx_connection_t *connection;
    void **ctx;
    void **main_conf;
    void **srv_conf;
    void **loc_conf;
    ngx_http_event_handler_pt read_event_handler;
    ngx_http_event_handler_pt write_event_handler;
    #if (NGX_HTTP_CACHE)
    ngx_http_cache_t *cache;
    #endif
    ngx_http_upstream_t *upstream;
    ngx_array_t *upstream_states;
    /* of ngx_http_upstream_state_t */
    ngx_pool_t *pool;
    ngx_buf_t *header_in;
    ngx_http_headers_in_t headers_in;
    ngx_http_headers_out_t headers_out;
    ngx_http_request_body_t *request_body;
    time_t lingering_time;
    time_t start_sec;
    ngx_msec_t start_msec;
    ngx_uint_t method;
    ngx_uint_t http_version;
    ngx_str_t request_line;
    ngx_str_t uri;
    ngx_str_t args;
    ngx_str_t exten;
    ngx_str_t unparsed_uri;
    ngx_str_t method_name;
    ngx_str_t http_protocol;
    ngx_chain_t *out;
    ngx_http_request_t *main;
    ngx_http_request_t *parent;
    ngx_http_postponed_request_t *postponed;
    ngx_http_post_subrequest_t *post_subrequest;
    ngx_http_posted_request_t *posted_requests;
    ngx_http_virtual_names_t *virtual_names;
    ngx_int_t phase_handler;
    ngx_http_handler_pt content_handler;
    ngx_uint_t access_code;
    ngx_http_variable_value_t *variables;
    /* ... */
}
</code></pre>
</blockquote>

<p>　　由于ngx_http_request_s定义比较长，这里我只截取了一部分。可以看到里面有诸如uri，args和request_body等HTTP常用信息。这里需要特别注意的几个字段是headers_in、headers_out和chain，它们分别表示request header、response header和输出数据缓冲区链表（缓冲区链表是Nginx I/O中的重要内容，后面会单独介绍）。<br/>
　　第一步是获取模块配置信息，这一块只要简单使用ngx_http_get_module_loc_conf就可以了。<br/>
　　第二步是功能逻辑，因为echo模块非常简单，只是简单输出一个字符串，所以这里没有功能逻辑代码。<br/>
　　第三步是设置response header。Header内容可以通过填充headers_out实现，我们这里只设置了Content-type和Content-length等基本内容，ngx_http_headers_out_t定义了所有可以设置的HTTP Response Header信息：</p>

<blockquote>
<pre><code>typedef struct {
    ngx_list_t headers;
    ngx_uint_t status;
    ngx_str_t status_line;
    ngx_table_elt_t *server;
    ngx_table_elt_t *date;
    ngx_table_elt_t *content_length;
    ngx_table_elt_t *content_encoding;
    ngx_table_elt_t *location;
    ngx_table_elt_t *refresh;
    ngx_table_elt_t *last_modified;
    ngx_table_elt_t *content_range;
    ngx_table_elt_t *accept_ranges;
    ngx_table_elt_t *www_authenticate;
    ngx_table_elt_t *expires;
    ngx_table_elt_t *etag;
    ngx_str_t *override_charset;
    size_t content_type_len;
    ngx_str_t content_type;
    ngx_str_t charset;
    u_char *content_type_lowcase;
    ngx_uint_t content_type_hash;
    ngx_array_t cache_control;
    off_t content_length_n;
    time_t date_time;
    time_t last_modified_time;
} ngx_http_headers_out_t;
</code></pre>
</blockquote>

<p>　　这里并不包含所有HTTP头信息，如果需要可以使用agentzh（春来）开发的Nginx模块HttpHeadersMore在指令中指定更多的Header头信息。<br/>
　　设置好头信息后使用ngx_http_send_header就可以将头信息输出，ngx_http_send_header接受一个ngx_http_request_t类型的参数。<br/>
　　第四步也是最重要的一步是输出Response body。这里首先要了解Nginx的I/O机制，Nginx允许handler一次产生一组输出，可以产生多次，Nginx将输出组织成一个单链表结构，链表中的每个节点是一个chain_t，定义在core/ngx_buf.h：</p>

<blockquote>
<pre><code>struct ngx_chain_s {
    ngx_buf_t *buf;
    ngx_chain_t *next;
};
</code></pre>
</blockquote>

<p>　　其中ngx_chain_t是ngx_chain_s的别名，buf为某个数据缓冲区的指针，next指向下一个链表节点，可以看到这是一个非常简单的链表。ngx_buf_t的定义比较长而且很复杂，这里就不贴出来了，请自行参考core/ngx_buf.h。ngx_but_t中比较重要的是pos和last，分别表示要缓冲区数据在内存中的起始地址和结尾地址，这里我们将配置中字符串传进去，last_buf是一个位域，设为1表示此缓冲区是链表中最后一个元素，为0表示后面还有元素。因为我们只有一组数据，所以缓冲区链表中只有一个节点，如果需要输入多组数据可将各组数据放入不同缓冲区后插入到链表。下图展示了Nginx缓冲链表的结构：<br/>
<img src="media/15038318990451/15038319355669.jpg" alt=""/><br/>
　　缓冲数据准备好后，用ngx_http_output_filter就可以输出了（会送到filter进行各种过滤处理）。ngx_http_output_filter的第一个参数为ngx_http_request_t结构，第二个为输出链表的起始地址&amp;out。ngx_http_out_put_filter会遍历链表，输出所有数据。<br/>
　　以上就是handler的所有工作，请对照描述理解上面贴出的handler代码。</p>

<h3 id="toc_4">组合Nginx Module</h3>

<p>　　上面完成了Nginx模块各种组件的开发下面就是将这些组合起来了。一个Nginx模块被定义为一个ngx_module_t结构，这个结构的字段很多，不过开头和结尾若干字段一般可以通过Nginx内置的宏去填充，下面是我们echo模块的模块主体定义：</p>

<blockquote>
<pre><code>ngx_module_t ngx_http_echo_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_echo_module_ctx, /* module context */
    ngx_http_echo_commands, /* module directives */
    NGX_HTTP_MODULE, /* module type */
    NULL, /* init master */
    NULL, /* init module */
    NULL, /* init process */
    NULL, /* init thread */
    NULL, /* exit thread */
    NULL, /* exit process */
    NULL, /* exit master */
    NGX_MODULE_V1_PADDING
};
</code></pre>
</blockquote>

<p>　　开头和结尾分别用NGX_MODULE_V1和NGX_MODULE_V1_PADDING 填充了若干字段，就不去深究了。这里主要需要填入的信息从上到下以依次为context、指令数组、模块类型以及若干特定事件的回调处理函数（不需要可以置为NULL），其中内容还是比较好理解的，注意我们的echo是一个HTTP模块，所以这里类型是NGX_HTTP_MODULE，其它可用类型还有NGX_EVENT_MODULE（事件处理模块）和NGX_MAIL_MODULE（邮件模块）。<br/>
　　这样，整个echo模块就写好了，下面给出echo模块的完整代码：<br/>
ngx_http_echo_module.c</p>

<blockquote>
<pre><code>#include &quot;ngx_config.h&quot;
#include &quot;ngx_core.h&quot;
#include &quot;ngx_http.h&quot;
typedef struct {
    ngx_str_t  ed;
} ngx_http_echo_loc_conf_t;
static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf);
static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child);
/* Directives */
static ngx_command_t  ngx_http_echo_commands[] = {
    { 
        ngx_string(&quot;echo&quot;),
        NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
        ngx_http_echo,
        NGX_HTTP_LOC_CONF_OFFSET,
        offsetof(ngx_http_echo_loc_conf_t, ed),
        NULL 
    },
    ngx_null_command
};
/* Http context of the module */
static ngx_http_module_t  ngx_http_echo_module_ctx = {
    NULL,                                  /* preconfiguration */
    NULL,                                  /* postconfiguration */
    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */
    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */
    ngx_http_echo_create_loc_conf,         /* create location configration */
    ngx_http_echo_merge_loc_conf           /* merge location configration */
};
/* Module */
ngx_module_t  ngx_http_echo_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_echo_module_ctx,             /* module context */
    ngx_http_echo_commands,                /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};
/* Handler function */
static ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r){
    ngx_int_t rc;
    ngx_buf_t *b;
    ngx_chain_t out;
    ngx_http_echo_loc_conf_t *elcf;
    elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
    if(!(r-&gt;method &amp; (NGX_HTTP_HEAD|NGX_HTTP_GET|NGX_HTTP_POST))){
        return NGX_HTTP_NOT_ALLOWED;
    }
    r-&gt;headers_out.content_type.len = sizeof(&quot;text/html&quot;) - 1;
    r-&gt;headers_out.content_type.data = (u_char *) &quot;text/html&quot;;
    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = elcf-&gt;ed.len;
    if(r-&gt;method == NGX_HTTP_HEAD){
        rc = ngx_http_send_header(r);
        if(rc != NGX_OK){
            return rc;
        }
    }
    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if(b == NULL){
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;Failed to allocate response buffer.&quot;);
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }
    out.buf = b;
    out.next = NULL;
    b-&gt;pos = elcf-&gt;ed.data;
    b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len);
    b-&gt;memory = 1;
    b-&gt;last_buf = 1;
    rc = ngx_http_send_header(r);
    if(rc != NGX_OK){
        return rc;
    }
    return ngx_http_output_filter(r, &amp;out);
}
static char *ngx_http_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf){
    ngx_http_core_loc_conf_t  *clcf;
    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_echo_handler;
    ngx_conf_set_str_slot(cf,cmd,conf);
    return NGX_CONF_OK;
}
static void *ngx_http_echo_create_loc_conf(ngx_conf_t *cf){
    ngx_http_echo_loc_conf_t  *conf;
    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_echo_loc_conf_t));
    if (conf == NULL) {
        return NGX_CONF_ERROR;
    }
    conf-&gt;ed.len = 0;
    conf-&gt;ed.data = NULL;
    return conf;
}
static char *ngx_http_echo_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child){
    ngx_http_echo_loc_conf_t *prev = parent;
    ngx_http_echo_loc_conf_t *conf = child;
    ngx_conf_merge_str_value(conf-&gt;ed, prev-&gt;ed, &quot;&quot;);
    return NGX_CONF_OK;
}
</code></pre>
</blockquote>

<h4 id="toc_5">Nginx模块的安装(如果之前nginx的安装是跟我上一个教程做的话目录可以照搬,否则需要改成你们nginx自己的安装目录和源码目录)</h4>

<p><strong>我的nginx源码目录在/usr/local/src/nginx-1.4.2，安装目录在/usr/local/nginx</strong><br/>
Nginx不支持动态链接模块，所以安装模块需要将模块代码与Nginx源代码进行重新编译。安装模块的步骤如下：<br/>
1、编写模块config文件，这个文件需要放在和模块源代码文件放在同一目录下。文件内容如下：</p>

<blockquote>
<pre><code>ngx_addon_name=模块完整名称
HTTP_MODULES=&quot;$HTTP_MODULES 模块完整名称&quot;
NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/源代码文件名&quot;
</code></pre>
</blockquote>

<p>2、查看nginx编译安装时的命令，安装了哪些模块</p>

<blockquote>
<pre><code>sudo /usr/local/nginx/nginx -V
</code></pre>
</blockquote>

<p>3、进入Nginx源代码目录，使用下面命令编译生成可执行文件</p>

<blockquote>
<pre><code>cd /usr/local/src/nginx-1.4.2
sudo ./configure --prefix=安装目录 --add-module=模块源代码文件目录 --之前安装nginx的配置参数 &amp;&amp; sudo make 
udo cp /usr/local/src/nginx-1.4.2/objs/nginx /usr/local/nginx/nginx 
</code></pre>
</blockquote>

<p>这样就完成了<br/>
举个详细的例子，模块源码就是上面的,直接复制即可,我的源代码文件放在~/nginx/ngx_http_echo_module下，我的config文件为：</p>

<blockquote>
<pre><code>ngx_addon_name=ngx_http_echo_module
HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_echo_module&quot;
NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_echo_module.c
</code></pre>
</blockquote>

<p>要添加的模块的目录结构如下:<br/>
<img src="media/15038318990451/15038319511220.jpg" alt=""/><br/>
首先查看nginx编译时的配置参数</p>

<blockquote>
<pre><code>sudo /usr/local/nginx/nginx -V
</code></pre>
</blockquote>

<p><img src="media/15038318990451/15038319562374.jpg" alt=""/><br/>
然后进入源码nginx的源码目录编译,只需在原来的编译参数后加模块参数就行了：(注意目录)</p>

<blockquote>
<pre><code>cd /usr/local/src/nginx-1.4.2
sudo ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --prefix=/usr/local/nginx --with-http_ssl_module --add-module=/home/wj/nginx/ngx_http_echo_module
</code></pre>
</blockquote>

<p><img src="media/15038318990451/15038319638696.jpg" alt=""/></p>

<p>在configure的时候我们可以看到模块被configure文件发现了<br/>
<img src="media/15038318990451/15038319718777.jpg" alt=""/></p>

<p>configure完毕,开始make编译(仍在nginx源码目录):<br/>
这里要注意Nginx不像apache,模块不是动态添加的（换句话就是说，所有的模块都要预先编译进Nginx 的二进制可执行文件）。</p>

<blockquote>
<pre><code>sudo make
</code></pre>
</blockquote>

<p><strong>make完毕,千万不要sudo make install了</strong>,很多参考文档都是install,然并卵,install之后在改配置文件的时候还是会有错,而且一旦configure的时候参数把依赖库也写进去的话你就又把那些已经编译过的依赖又编译了一遍,耗时又浪费系统资源,所以,在安装nginx的时候configure时可以先不指定依赖,参数只写它的安装目录,如果没有报错说明你的系统已经有这些依赖了.我前面在安装nginx前特定下了pcre、zlib、openssl，还编译安装，后来发现这些步骤根本就是白做了，因为系统已经有这些依赖了。希望安装的可以引以为戒。在make之后已经生成了新的nginx可执行文件,在/usr/local/src/nginx-1.4.2/objs下,<br/>
<img src="media/15038318990451/15038319787083.jpg" alt=""/><br/>
此时的nginx是已经重新编译过得了，可以直接拷贝到nginx的安装目录下。</p>

<blockquote>
<pre><code>sudo mv /usr/local/nginx/nginx /usr/local/nginx/nginx.old
sudo /usr/local/nginx/nginx -s stop(如果你的nginx开着的话，执行这步)
sudo cp /usr/local/src/nginx-1.4.2/objs/nginx /usr/local/nginx/nginx
</code></pre>
</blockquote>

<p>此时，基本上大功告成，你的新模块已经编译进了nginx中。<br/>
下面测试一下，修改nginx.conf配置文件，增加以下一项配置：</p>

<blockquote>
<pre><code>location /echo {
    echo &quot;This is my first nginx module!!!&quot;;
}
</code></pre>
</blockquote>

<p>然后开启nginx用curl测试一下：</p>

<blockquote>
<pre><code>sudo /usr/local/nginx/nginx
curl -i http://localhost/echo
</code></pre>
</blockquote>

<p>结果如下：<br/>
<img src="media/15038318990451/15038319847915.jpg" alt=""/></p>

<p>这个nginx模块的开发流程到此结束！下面再看看nginx加载多模块的流程。假如已经有开发好的2个模块：<br/>
<img src="media/15038318990451/15038319915704.jpg" alt=""/><br/>
配置configure文件：</p>

<blockquote>
<pre><code> sudo ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --prefix=/usr/local/nginx --with-http_ssl_module --add-module=/home/wj/nginx/ngx_http_echo_module --add-module=/home/wj/nginx/ngx_http_hello_world_module
</code></pre>
</blockquote>

<p><img src="media/15038318990451/15038319994230.jpg" alt=""/><br/>
configure文件发现了2个开发模块：<br/>
<img src="media/15038318990451/15038320040324.jpg" alt=""/><br/>
然后开始编译：<br/>
<img src="media/15038318990451/15038320105000.jpg" alt=""/><br/>
生成了可执行文件：<br/>
<img src="media/15038318990451/15038320205384.jpg" alt=""/><br/>
拷贝至nginx安装目录：</p>

<blockquote>
<pre><code>sudo /usr/local/nginx/nginx -s stop（拷贝时若提示文本文件忙，可以先停掉nginx）
sudo cp ./objs/nginx /usr/local/nginx/nginx
</code></pre>
</blockquote>

<p>在nginx.conf配置文件中添加location<br/>
<img src="media/15038318990451/15038320257154.jpg" alt=""/></p>

<p>然后开启nginx用curl测试一下：</p>

<blockquote>
<pre><code>sudo /usr/local/nginx/nginx
curl -i http://localhost/hello_world
curl -i http://localhost/echo
</code></pre>
</blockquote>

<p>结果如下：<br/>
<img src="media/15038318990451/15038320416566.jpg" alt=""/></p>

<p>浏览器端：<br/>
<img src="media/15038318990451/15038320465310.jpg" alt=""/><br/>
<img src="media/15038318990451/15038320531990.jpg" alt=""/></p>

<p>单模块多模块的编译使用都已经讲完了，下面总结一下：</p>

<blockquote>
<pre><code>1、在安装nginx的时候，如果你在configure的时候参数没有加pcre、zlib、openssl等依赖也没报错那就不需要编译安装这些依赖
2、如果安装nginx时，configure报错了，说明你的系统缺少这些依赖，你还是老老实实的先编译安装这些库，再在configure的配置参数中加入这些库，并且在以后的模块开发中，每次加入模块时，都要在configure配置参数中加入这些库。
3、在编译完新模块后，你可以选择install ，也可以选择不install，install会把你所有已经编译好的文件都覆盖安装一遍，很费时间资源，而且我在install之后还遇到了莫名其妙问题。所以，可以在make之后，直接把编译好的nginx二进制文件放到nginx安装目录下，直接使用。
</code></pre>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下配置rsync服务器]]></title>
    <link href="weijing24.github.io/15038318551859.html"/>
    <updated>2017-08-27T19:04:15+08:00</updated>
    <id>weijing24.github.io/15038318551859.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">一、简介</h3>

<p>　　rsync是一个远程数据同步工具，可以快速同步多台主机间的文件。Rsync使用所谓的“Rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。当然不仅仅是远程，在本地同步、复制数据也可以使用这个命令，也只传送文件的不同部分。</p>

<h3 id="toc_1">二、配置rsync server</h3>

<p>　　1、启动rsync server<br/>
　　#vim /etc/xinetd.d/rsync<br/>
　　把disable的yes改为no</p>

<blockquote>
<pre><code>service rsync{
    disable = no
    socket_type     = stream
    wait            = no
    user            = root
    server          = /usr/bin/rsync
    server_args     = --daemon
    log_on_failure  += USERID
}
</code></pre>
</blockquote>

<p>　　2、配置/etc/rsyncd.conf(需要手动生成)</p>

<blockquote>
<pre><code>全局参数
uid = root                                  //运行RSYNC守护进程的用户
gid = root                                  //运行RSYNC守护进程的组
use chroot = no                 //不使用chroot
max connections = 4             // 最大连接数为4
strict modes =yes                //是否检查口令文件的权限
port = 873                      //默认端口873
pid file = /var/run/rsyncd.pid      //pid文件的存放位置
lock file = /var/run/rsync.lock     //锁文件的存放位置
log file = /var/log/rsyncd.log      //日志记录文件的存放位置
模块参数
[backup]                   //这里是认证的模块名，在client端需要指定
path = /home/backup/        //需要备份的目录,不可缺少！
comment = This is a test       //这个模块的注释信息 
ignore errors                //可以忽略一些无关的IO错误
read only = yes              // 只读
#list = no                   //不允许列文件
auth users = wj             //认证的用户名，如果没有这行则表明是匿名，此用户与系统无关
secrets file = /etc/rsync.pas           //密码和用户名对比表，密码文件自己生成
hosts allow = 192.168.1.1,10.10.10.10      //允许主机
hosts deny = 0.0.0.0/0                   //禁止主机
#transfer logging = yes
</code></pre>
</blockquote>

<p>　　3、配置rsync密码（在上边的配置文件中已经写好路径）<br/>
　　/etc/rsync.pas（名字随便写，只要和上边配置文件里的一致即可），格式(一行一个用户)<br/>
　　账号：密码<br/>
  　#vi /etc/rsync.pas</p>

<blockquote>
<pre><code>wj:1111
</code></pre>
</blockquote>

<p>　　权限：因为rsync.pas存储了rsync服务的用户名和密码，所以非常重要。要将rsync.pas设置为root拥有, 且权限为600。</p>

<blockquote>
<pre><code>cd /etc
chown root:root rsync.pas 
chmod 600 rsync.pas
</code></pre>
</blockquote>

<p>　　4、让配置生效<br/>
　　service xinetd restart</p>

<p>　　5、同步文件<br/>
　　①从SERVER端取文件<br/>
　　rsync -vzrtopg --progress --delete wj@192.168.78.129::backup /home/backup --password-file=/etc/rsync.pas<br/>
<img src="media/15038318551859/15038318752900.jpg" alt=""/><br/>
　　②向SERVER端上传文件<br/>
　　rsync -vzrtopgP . wj@192.168.78.129::backup<br/>
<img src="media/15038318551859/15038318807439.jpg" alt=""/></p>

<h3 id="toc_2">三、rsync命令参数详解　　</h3>

<p>　　<strong>-a存档模式</strong><br/>
　　<strong>-v表示verbose详细显示</strong><br/>
　　<strong>-P表示代替-partial和-progress两者的选项功能</strong><br/>
　　-z表示压缩<br/>
　　-r表示recursive递归<br/>
　　-t表示保持原文件创建时间<br/>
　　-o表示保持原文件属主<br/>
　　-p表示保持原文件的参数<br/>
　　-g表示保持原文件的所属组<br/>
　　-e ssh建立起加密的连接。<br/>
　　<strong>--delete是指如果服务器端删除了这一文件，那么客户端也相应把文件删除，保持真正的一致。</strong><br/>
　　<strong>--exclude不包含/ins目录</strong><br/>
　　--partial阻止rsync在传输中断时删除已拷贝的部分(如果在拷贝文件的过程中，传输被中断，rsync的默认操作是撤消前操作，即从目标机上<br/>
　　删除已拷贝的部分文件。)<br/>
　　--progress是指显示出详细的进度情况<br/>
　　--size-only 这个参数用在两个文件夹中的差别仅是源文件夹中有一些新文件，不存在重名且被修改过的文件，因为这种文件有可能会因为内容被修改可大小一样，而被略过。这个参数可以大大地提高同步的效率，因为它不需要检查同名文件的内容是否相同。<br/>
　　--password-file来指定密码文件，内容包含server端指定认证用户的密码。这样就可以在脚本中使用而无需交互式地输入验证密码了，这里需要注意的是这份密码文件权限属性要设得只有属主可读。</p>

<p>　　<strong>wj@192.168.78.129::backup</strong><br/>
　　<strong>wj是指server端指定认证的用户</strong><br/>
　　<strong>192.168.78.129是指服务器端的ip</strong><br/>
　　<strong>::backup 表示服务器端需要同步的模块名称；</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux多线程编程入门]]></title>
    <link href="weijing24.github.io/15038316827096.html"/>
    <updated>2017-08-27T19:01:22+08:00</updated>
    <id>weijing24.github.io/15038316827096.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">背景知识:</h3>

<p>　　在前一个实训中我们介绍了进程，但有时人们认为用fork调用来创建新进程的代价太高。在这种情况下，如果能让一个进程同时做零件事情或至少看起来是这样将会非常有用。而且，你可能希望能有两件或更多的事情以一种非常紧密的方式同时发生。这就是需要线程发挥作用的时候了。<br/>
　　线程，有时被称为轻量级进程(Lightweight Process，LWP），是<strong>程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。</strong>另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，<strong>线程自己不拥有系统资源</strong>，只拥有一点儿在运行中必不可少的资源，<strong>但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</strong>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。<br/>
　　线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>

<h4 id="toc_1">1.创建线程</h4>

<p>任务描述：</p>

<ul>
<li>在主线程中创建一个新线程</li>
<li>在新线程中输出运行信息，在结束时返回主线程</li>
</ul>

<p>相关知识:<br/>
int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);<br/>
参数说明：<br/>
thread：指向pthread_create类型的指针，用于引用新创建的线程。<br/>
attr：用于设置线程的属性，一般不需要特殊的属性，所以可以简单地设置为NULL。<br/>
*(*start_routine)(void *)：传递新线程所要执行的函数地址。<br/>
<strong>arg：新线程所要执行的函数的参数</strong></p>

<p>thread_exit函数<br/>
　　原型：void pthread_exit（void *retval）<br/>
　　功能：使用函数pthread_exit退出线程，这是线程的主动行为；由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出线程所占用的资源并不会随着线程的终止而得到释放，但是可以用pthread_join()函数来同步并释放资源。<br/>
　　说明：retval：pthread_exit()调用线程的返回值，可由其他函数如pthread_join来检索获取。如果在线程中使用exit()函数退出，那么整个的进程将会退出，那么如果此时你还有一些其它需要做的事情没有完成呢，这并不是我们所希望的。</p>

<p>pthread_join函数<br/>
　　原型：extern int pthread_join __P ((pthread_t __th, void **__thread_return));<br/>
　　功能：函数pthread_join用来等待一个线程的结束。这个函数是一个线程阻塞的函数，调用它的线程将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是象我们上面的例子一样，函数结束了，调用它的线程也就结束了<br/>
　　说明：第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。pthread_join()的调用者将挂起并等待th线程终止，retval是pthread_exit()调用者线程（线程ID为th）的返回值，如果thread_return不为NULL,则*thread_return=retval。需要注意的是一个线程仅允许唯一的一个线程使用 pthread_join()等待它的终止，并且被等待的线程应该处于可join状态，即非DETACHED状态。</p>

<p>编译和链接：<br/>
gcc –o thread1 thread1.c –lpthread<br/>
main.c:</p>

<blockquote>
<pre><code>#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void print_message_function(void *ptr){
    int i;
    for(i=0;i&lt;5;i++)
        printf(&quot;%s:%d\n&quot;,(char *)ptr,i);
    pthread_exit(&quot;success&quot;);
}
int main(void){
    int tmp1;
    void *retval;
    //pthread_t用于声明线程ID
    pthread_t thread1;
    char *message1=&quot;thread1&quot;;
    int ret_thrd1;
    ret_thrd1=pthread_create(&amp;thread1,NULL,(void *)&amp;print_message_function,(void *)message1);
    if(ret_thrd1!=0)
        printf(&quot;fail to create thread1\n&quot;);
    else
        printf(&quot;success to create thread1\n&quot;);
    //挂起并等待thread1线程终止，retval是pthread_exit()调用者线程（线程ID为th）的返回值
    tmp1=pthread_join(thread1,&amp;retval);
    printf(&quot;%s\n&quot;,(char *)retval);
    if(tmp1!=0){
        printf(&quot;can&#39;t join with thread1\n&quot;);
        return -1;
    }
    printf(&quot;thread1 end\n&quot;);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_2">2.在两个线程之间实现交替执行输出</h4>

<p>任务描述：</p>

<ul>
<li>主线程先输出“This is a thread0”，然后新线程输出”this is thread2“，一直交替到结束</li>
<li>同时访问全局变量，修改变量的值，并打印</li>
</ul>

<p>相关知识：<br/>
　　如果电脑是单核的，按照操作系统理论严格来说，多线程并不是多个线程一起运行的。因为多线程实际上是多个线程之间轮流执行的，就是将一个时间段分成若干个时间片，每个线程只运行一个时间片，由于时间片极短,而且电脑运行极快，线程之间切换也极快,几乎可以看做是并行运行的，也就是说可以看成是同时运行的.但实际却不是的同时运行的。<br/>
main.c：</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
int flag=0,a=0;
void *thread(){
    int i=0;
    while(i&lt;10){
        if(flag==1){
            i++;a++;
            printf(&quot;This is a pthread,a=%d\n&quot;,a);
            flag=0;
        }
    }
    pthread_exit(NULL);
}
int main(void){
    pthread_t id;
    int i=0,ret;
    ret=pthread_create(&amp;id,NULL,thread,NULL);
    if(ret!=0){
        printf (&quot;Create pthread error!\n&quot;);
        exit(1);
    }
    while(i&lt;10){
        if(flag==0){ 
            i++;a++;
            printf(&quot;This is the main process,a=%d\n&quot;,a);
            flag=1; 
        }
    }   
    pthread_join(id,NULL);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_3">3.使用信号量进行线程同步</h4>

<p>任务描述:</p>

<ul>
<li>主线程输入字符,输入end结束</li>
<li>副线程统一字符个数,使用信号量进行同步</li>
</ul>

<p>相关知识:<br/>
①信号量创建<br/>
　　信号量通过sem_init函数创建，它的定义如下所示：<br/>
　　　　#include &quot;semaphore.h&quot;<br/>
　　　　int sem_init(sem_t *sem, int pshared, unsigned int value);</p>

<p>　　参数说明：<br/>
　　sem：信号量对象。<br/>
　　pshared：控制信号量的类型，0表示这个信号量是当前进程的局部信号量，否则，这个信号量就可以在多个进程之间共享。<br/>
　　value：信号量的初始值。<br/>
　　这个函数初始化由sem指向的信号量对象，设置它的共享选项，并给它一个初始的整数值。pshared参数控制信号量的类型。</p>

<p>②信号量控制<br/>
　　#include &quot;semaphore.h&quot;<br/>
　　int sem_wait(sem_t *sem);<br/>
　　int sem_post(sem_t *sem);<br/>
　　这两个函数都以一个指针为参数，该指针指向的对象是由sem_init调用初始化的信号量。<br/>
　　sem_post的作用是以原子操作的方式给信号量的值加1。所谓原子操作是指，如果两个线程企图同时给一个信号量加1，它们之间不会互相干扰，而不像如果两个程序同时对同一个文件进行读取、增加、写入操作时可能会引起冲突。 <br/>
　　sem_wait的作用是以原子操作的方式给信号量的值减1，但它会等到信号量非0时才会开始减法操作。如果对值为0的信号量调用sem_wait，这个函数就会等待，直到有线程增加了该信号量的值使其不再为0。<br/>
　　还有另外一个信号量函数sem_trywait，它是sem_wait的非阻塞版本。</p>

<p>③信号量销毁<br/>
　　#include &quot;semaphore.h&quot;<br/>
　　int sem_destory(sem_t *sem);<br/>
　　与前几个函数一样，这个函数也以一个信号量指针为参数。并清理该信号量所拥有的资源。如果试图清理的信号量正被一些线程等待，就会收到一个错误。<br/>
　　与大多数Linux函数一样，这些函数在成功时都返回0。</p>

<blockquote>
<pre><code>#include &quot;unistd.h&quot;
#include &lt;pthread.h&gt;  
#include &quot;semaphore.h&quot;
#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;  
//线程函数  
void *thread_func(void *msg);  
sem_t sem;//信号量
#define MSG_SIZE 512
void* thread_func(void *msg){  
    //此时信号量为0，子线程阻塞自身等待主线程信号量+1  
    sem_wait(&amp;sem);  
    char *ptr = msg;  
    while(strcmp(&quot;end\n&quot;, msg) != 0){  
        int i = 0; 
        for(; ptr[i] != &#39;\0&#39;; ++i);
        printf(&quot;You input %d characters\n&quot;, i-1);  
        //此时信号量为1，把信号量减1  
        sem_wait(&amp;sem);  
    }  
    //退出线程  
    pthread_exit(NULL);  
}
int main(void){  
    int res = -1;  
    pthread_t thread;  
    void *thread_result = NULL;  
    char msg[MSG_SIZE];  
    //初始化信号量，其初值为0  
    res = sem_init(&amp;sem, 0, 0);  
    if(res == -1){  
        perror(&quot;semaphore intitialization failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }
    //创建线程，并把msg作为线程函数的参数  
    res = pthread_create(&amp;thread, NULL, thread_func,(void *)msg);  
    if(res != 0){  
        perror(&quot;pthread_create failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }
    //输入信息，以输入end结束，由于fgets会把回车（\n）也读入，所以判断时就变成了“end\n”  
    printf(&quot;Input some text. Enter &#39;end&#39;to finish...\n&quot;);  
    while(strcmp(&quot;end\n&quot;, msg) != 0){  
        fgets(msg, MSG_SIZE, stdin);  
        //把信号量加1，让子线程执行  
        sem_post(&amp;sem);  
    }  
    printf(&quot;Waiting for thread to finish...\n&quot;);  
    //等待子线程结束  
    res = pthread_join(thread, &amp;thread_result);  
    if(res != 0){  
        perror(&quot;pthread_join failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }  
    printf(&quot;Thread joined\n&quot;);  
    //清理信号量  
    sem_destroy(&amp;sem);  
    exit(EXIT_SUCCESS);  
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_4">4.用互斥量实现同步</h4>

<p>任务描述:</p>

<ul>
<li>模拟实现一个简单的火车售票系统,两个线程分别打印出票号,票号不能重复</li>
</ul>

<p>相关知识:<br/>
　　另一种用在多线程程序中同步访问的方法是使用互斥量。它允许程序员锁住某个对象，使得每次只能有一个线程访问它。为了控制对关键代码的访问，必须在进入这段代码之前锁住一个互斥量，然后在完成操作之后解锁它。<br/>
　　用于互斥量的基本函数和用于信号量的函数非常相似，它们的定义如下所示：</p>

<blockquote>
<pre><code>#include &lt;pthread.h&gt; 
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t, *mutexattr);
int pthread_mutex_lock(pthread_mutex_t *mutex); 
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>
</blockquote>

<p>　　与其他函数一样，成功时返回0，失败时将返回错误代码，但这些函数并不设置errno，所以必须对函数的返回代码进行检查。<br/>
　　与信号量类似，这些函数的参数都是一个先前申明过的对象的指针。对互斥量来说，这个对象的类型为pthread_mutex_t.<br/>
　　pthread_mutex_init函数中的属性参数允许我们设置互斥量的属性，而属性控制着互斥量的行为。属性类型默认为fast，但它有一个缺点：如果程序试图对一个已经加了锁的互斥量调用pthread_mutex_lock，程序就会被阻塞，而又因为拥有互斥量的这个线程正是现在被阻塞的线程，所以互斥量就永远也不会被解锁了，程序也就进入死锁状态。这个问题可以通过改变互斥量的属性来解决。int pthread_mutex_destroy(pthread_mutex_t *mutex);<br/>
main.c:</p>

<blockquote>
<pre><code>#include &quot;unistd.h&quot;
#include &lt;pthread.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;    
//声明线程函数和互斥量  
void* thread_func(void *msg);  
pthread_mutex_t mutex;  
#define MSG_SIZE 512  
int a=0,flag=0;
void* thread_func(void *msg){  
    int i = 1;  
    char *ptr = msg;  
    while(i&lt;10){
    //把互斥量mutex加锁，以确保同一时间只有该线程可以访问  
        pthread_mutex_lock(&amp;mutex); 
        if(flag==0){ 
            i++;a++;
            printf(&quot;This is the main process,a=%d\n&quot;,a);
            flag=1;
            sleep(1);
        }
     //把互斥量mutex解锁，让其他的线程可以访问  
        pthread_mutex_unlock(&amp;mutex);  
    }
    //退出线程  
    pthread_exit(NULL);  
}  
int main(void){  
    int res = -1,i=1;  
    pthread_t thread;  
    void *thread_result = NULL;  
    char msg[MSG_SIZE] = {&#39;\0&#39;};  
    //初始化互斥量，使用默认的互斥量属性  
    res = pthread_mutex_init(&amp;mutex, NULL);  
    if(res != 0){  
        perror(&quot;pthread_mutex_init failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }  
    //创建子线程，并把msg作为线程函数的参数传递给thread_func  
    res = pthread_create(&amp;thread, NULL, thread_func, msg);  
    if(res != 0){  
        perror(&quot;pthread_create failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }
    while(i&lt;10){
        //把互斥量mutex加锁，以确保同一时间只有该线程可以访问  
        pthread_mutex_lock(&amp;mutex);  
        if(flag==1){
            i++;a++;
            printf(&quot;This is a pthread,a=%d\n&quot;,a);
            flag=0;
            sleep(1);
        }
        //把互斥量mutex解锁，让其他的线程可以访问  
        pthread_mutex_unlock(&amp;mutex);
    } 
    printf(&quot;\nWaiting for thread finish...\n&quot;);  
    //等待子线程结束  
    res = pthread_join(thread, &amp;thread_result);  
    if(res != 0){  
        perror(&quot;pthread_join failed\n&quot;);  
        exit(EXIT_FAILURE);  
    }  
    printf(&quot;Thread joined\n&quot;);  
    //清理互斥量  
    pthread_mutex_destroy(&amp;mutex);  
    exit(EXIT_SUCCESS);  
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_5">5.线程属性设置</h4>

<p>任务描述:</p>

<ul>
<li>创建一个脱线线程,即该线程不需要返回主线程.可以通过修改线程属性来设置</li>
</ul>

<p>相关知识:<br/>
　　在前面的示例中，我们都在程序退出之前用pthread_join对线程再次进行同步，如果我们想让线程向创建它的线程返回数据就需要这样做。但有时也会有这种情况，我们既不需要第二个线程向主线程返回信息，也不想主线程等待它结束.我们可以创建这一类型的线程，它们被称为脱离线程(detached thread)。可以通过修改线程属性或调用pthread_detach的方法来创建它们。<br/>
　　第一种方法需要用到的最重要的函数是pthread_attr_init，它的作用是初始化一个线程属性对象。<br/>
　　下面来介绍一些常用函数<br/>
　　(1) int pthread_attr_init (pthread_attr_t* attr);<br/>
　　功能：对线程属性变量的初始化。<br/>
　　attr：线程属性。<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(2) int pthread_attr_setscope (pthread_attr_t* attr, int scope);<br/>
　　功能：设置线程绑定属性。<br/>
　　attr：线程属性。<br/>
　　scope：PTHREAD_SCOPE_SYSTEM(绑定)；PTHREAD_SCOPE_PROCESS(非绑定)<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(3) int pthread_attr_setdetachstate (pthread_attr_t* attr, int detachstate);<br/>
　　功能：设置线程分离属性。<br/>
　　attr：线程属性。<br/>
　　detachstate：PTHREAD_CREATE_DETACHED(分离)；PTHREAD_CREATE_JOINABLE（非分离）<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(4) int pthread_attr_setschedpolicy(pthread_attr_t* attr, int policy);<br/>
　　功能：设置创建线程的调度策略。<br/>
　　attr：线程属性；<br/>
　　policy：线程调度策略：SCHED_FIFO、SCHED_RR和SCHED_OTHER。<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(5) int pthread_attr_setschedparam (pthread_attr_t* attr, struct sched_param* param);<br/>
　　功能：设置线程优先级。<br/>
　　attr：线程属性。<br/>
　　param：线程优先级。<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(6) int pthread_attr_destroy (pthread_attr_t* attr);<br/>
　　功能：对线程属性变量的销毁。<br/>
　　attr：线程属性。<br/>
　　函数返回值：成功：0，失败：-1<br/>
　　(7)其他<br/>
　　int pthread_attr_setguardsize(pthread_attr_t* attr,size_t guardsize);//设置新创建线程栈的保护区大小。<br/>
　　int pthread_attr_setinheritsched(pthread_attr_t* attr, int inheritsched);//决定怎样设置新创建线程的调度属性。<br/>
　　int pthread_attr_setstack(pthread_attr_t* attr, void* stackader,size_t stacksize);//两者共同决定了线程栈的基地址以及堆栈的最小尺寸（以字节为单位）。<br/>
　　int pthread_attr_setstackaddr(pthread_attr_t* attr, void* stackader);//决定了新创建线程的栈的基地址。<br/>
　　int pthread_attr_setstacksize(pthread_attr_t* attr, size_t stacksize);//决定了新创建线程的栈的最小尺寸（以字节为单位）。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &quot;unistd.h&quot;
char message[]=&quot;hello world&quot;;
int thread_finished=0;
void *thread(void *arg){
    printf(&quot;thread is running\n&quot;);
    sleep(5);
    thread_finished=1;
    pthread_exit(NULL);
}
int main(void){
    int  res;
    pthread_t a_thread;
    pthread_attr_t thread_attr;
    //初始化线程属性对象
    res=pthread_attr_init(&amp;thread_attr);
    if(res!=0){
        perror(&quot;Attribute creation failed\n&quot;);
        exit(EXIT_FAILURE);
    }    
    res=pthread_attr_setdetachstate(&amp;thread_attr,PTHREAD_CREATE_DETACHED);
    if(res!=0){
        perror(&quot;Setting detached attribute failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    res=pthread_create(&amp;a_thread,&amp;thread_attr, thread,(void *)message);
    if (res!=0){
        perror(&quot;Thread creation failed\n&quot;);
        exit(EXIT_FAILURE);
    }    
    (void)pthread_attr_destroy(&amp;thread_attr);
    while(!thread_finished){
        sleep(1);
        printf(&quot;Waiting for thread to finish...\n&quot;);
    }
    printf(&quot;thread finished,bye\n&quot;);
    exit(EXIT_SUCCESS);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_6">6.取消一个线程</h4>

<p>任务描述:</p>

<ul>
<li>在主线程中取消创建的线程</li>
</ul>

<p>相关知识:<br/>
　　有时，我们想让一个线程可以要求另一个线程终止，线程有方法做到这一点，与信号处理一样，线程可以在被要求终止时改变其行为。<br/>
　　先来看用于请求一个线程终止的函数： <br/>
int pthread_cancel(pthread_t thread);<br/>
　　这个函数简单易懂，提供一个线程标识符，我们就可以发送请求来取消它。线程可以用pthread_setcancelstate设置自己的取消状态。　　<br/>
int pthread_setcancelstate(int state, int *oldstate);<br/>
　　参数说明：<br/>
　　state：可以是PTHREAD_CANCEL_ENABLE允许线程接收取消请求，也可以是PTHREAD_CANCEL_DISABLE忽略取消请求。<br/>
　　oldstate：获取先前的取消状态。如果对它没兴趣，可以简单地设置为NULL。如果取消请求被接受了，线程可以进入第二个控制层次，用pthread_setcanceltype设置取消类型。 <br/>
int pthread_setcanceltype(int type, int *oldtype);<br/>
　　参数说明：<br/>
　　type：可以取PTHREAD_CANCEL_ASYNCHRONOUS，它将使得在接收到取消请求后立即采取行动；另一个是PTHREAD_CANCEL_DEFERRED，它将使得在接收到取消请求后，一直等待直到线程执行了下述函数之一后才采取行动：pthread_join、pthread_cond_wait、pthread_cond_timedwait、pthread_testcancel、sem_wait或sigwait。<br/>
　　oldtype：允许保存先前的状态，如果不想知道先前的状态，可以传递NULL。<br/>
　　默认情况下，线程在启动时的取消状态为PTHREAD_CANCEL_ENABLE，取消类型是PTHREAD_CANCEL_DEFERRED。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &quot;unistd.h&quot;
void *thread(){
    int i,res;
    res=pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL);
    if(res!=0){
        perror(&quot;Thread pthread_seetcancelstate failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    res=pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED,NULL);
    if(res!=0){
        perror(&quot;Thread pthread_seetcanceltype failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    for(i=0;i&lt;10;i++){
        printf(&quot;Thread is running ...\n&quot;);
        sleep(1);
    }
    pthread_exit(0);
}
int main(void){
    int  res;
    pthread_t a_thread;
    void *thread_result;
    res=pthread_create(&amp;a_thread, NULL, thread, NULL);
    if (res!=0){
        perror(&quot;Thread creation failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    sleep(3);
    printf(&quot;Canceling thread...\n&quot;);
    res=pthread_cancel(a_thread);
    if (res!=0){
        perror(&quot;Thread cancelation failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;Waiting for thread to finish...\n&quot;);
    res=pthread_join(a_thread, &amp;thread_result);
    if (res!=0){
        perror(&quot;Thread join failed\n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;thread finished\n&quot;);
    exit(EXIT_SUCCESS);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_7">7.创建多线程</h4>

<p>任务描述:</p>

<ul>
<li>要求这些线程以随机的顺序结束</li>
<li>在每个创建的线程下打印线程产生顺序,例如:如果是第三个产生的线程,打印&quot;我是第三个线程&quot;.在线程结束的时候打印&quot;第三个线程结束了&quot;</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#define NUM_THREADS 6
void *thread_function(void *arg){
    int my_number = *(int *)arg;
    int rand_num;
    printf(&quot;I&#39;m numner %d thread\n&quot;, my_number);
    rand_num=1+(int)(9.0*rand()/(RAND_MAX+1.0));
    sleep(rand_num);
    printf(&quot;number %d thread end\n&quot;,my_number);
    pthread_exit(NULL);
}
int main(void){
    int res;
    pthread_t a_thread[NUM_THREADS];
    void *thread_result;
    int lots_of_threads;
    for(lots_of_threads = 0;lots_of_threads&lt;NUM_THREADS;lots_of_threads++) {
        res=pthread_create(&amp;(a_thread[lots_of_threads]),NULL, thread_function, (void *)&amp;lots_of_threads);
        if (res != 0){
            perror(&quot;Thread creation failed&quot;);
            exit(EXIT_FAILURE);
        }
        sleep(1);
    }
    printf(&quot;Waiting for threads to finish...\n&quot;);
    for(lots_of_threads = NUM_THREADS - 1; lots_of_threads &gt;= 0;lots_of_threads--){
        res = pthread_join(a_thread[lots_of_threads], &amp;thread_result);
        if(res != 0){
            perror(&quot;pthread_join failed\n&quot;);
        }
    }
    printf(&quot;All done\n&quot;);
    exit(EXIT_SUCCESS);
    return 0;
}
</code></pre>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux进程编程入门]]></title>
    <link href="weijing24.github.io/15038316680304.html"/>
    <updated>2017-08-27T19:01:08+08:00</updated>
    <id>weijing24.github.io/15038316680304.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1.进程的创建与操作</h4>

<p>任务描述：</p>

<ul>
<li>在父进程中创建一个全局变量，一个局部变量，并赋予初始值，用fork函数创建子进程。在子进程中对父进程的变量进行自加操作，并且输出变量值，然后父进程睡眠一段时间</li>
<li>各进程结束前输出进程与父进程号，全局及局部变量值</li>
</ul>

<p>相关知识：<br/>
　　由 fork 创建的新进程被称为子进程(child process)。该函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是 0,而父进程的返回值则是新子进程的进程 ID。将子进程 ID 返回给父进程的理由是:因为一个进程的子进程可以多于一个,所以没有一个函数使一个进程可以获得其所有子进程的进程 ID。fork 使子进程得到返回值0 的理由是:一个进程只会有一个父进程,所以子进程总是可以调用 getppid 以获得其父进程的进程 ID (进程 ID 0 总是由交换进程使用,所以一个子进程的进程 ID 不可能为 0 )。子进程和父进程共享很多资源,除了打开文件之外,很多父进程的其他性质也由子进程继承</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
int a=1;
int main(void){
    int b=2;
    pid_t pid;
    pid=fork();
    if(pid==0){
        printf(&quot;PID is %d,&quot;,getpid());
        printf(&quot;PPID is %d\n&quot;,getppid());
        a++;b++;
        printf(&quot;a=%d,b=%d\n&quot;,a,b);
　　　　　exit(0);
    }
    else{
        sleep(1);
        printf(&quot;after fork\n&quot;);
        printf(&quot;PID is %d,&quot;,getpid()); 
        printf(&quot;PPID is %d\n&quot;,getppid());
        printf(&quot;a=%d,b=%d\n&quot;,a,b);
    } 
    sleep(5);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_1">2.vfork函数的使用</h4>

<p>任务描述:</p>

<ul>
<li>在父进程中创建一个局部变量,并赋予初始值0</li>
<li>采用fork函数创建子进程,调用wait函数等待子进程结束,在父进程中输出局部变量值</li>
</ul>

<p>相关知识:<br/>
　　fork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。<br/>
　　vfork 用于创建新进程,而该新进程的目的是exec一个新程序(执行一个可执行的文件)。新进程有自己的地址空间,因此 vfork 函数并不将父进程的地址空间完全复制到子进程中。<br/>
　　在使用 vfork()时,必须在子进程中调用 exit()函数调用,否则会出现:_new_exitfn:Assertion `l != ((void *)0)&#39; failed<br/>
　　wait()会暂时停止目前进程的执行,直到有信号来到或子进程结束。如果在调用 wait()时子进程已经结束,则 wait()会立即返回子进程结束状态值。子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一快返回。如果不在意结束状态值,则参数 status 可以设成 NULL。通过vfork函数创建另一个子进程,调用wait函数等待子进程结束,在父进程中输出局部变量值</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
int main(void){
    int b=0,i;
    pid_t pid;
    printf(&quot;fork choose 0;vfork choose 1\n&quot;);
    scanf(&quot;%d&quot;,&amp;i);
    switch(i){
        case 0:pid=fork();break;
        case 1:pid=vfork();break;
        default:printf(&quot;error\n&quot;);
    }
    if(pid==0){
        b++;
        exit(0);
    }
    wait(pid);
    printf(&quot;data is %d\n&quot;,b);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_2">3.子进程与父进程执行的顺序</h4>

<p>任务描述:</p>

<ul>
<li>用fork函数创建子进程,子进程创建一个for循环,每次sleep 1s再打印输出子进程的pid和自加变量i的值</li>
<li>父进程sleep 3s,再打印输出父进程的pid,以及自加变量i的值</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
int main(void){
    int i;
    pid_t pid;
    pid=fork();
    if(pid==0){
        for(i=1;i&lt;6;i++){
            sleep(1);
            printf(&quot;process ID %d,i=%d\n&quot;,getpid(),i);
            }
            exit(0);
        }
    else if(pid &gt; 0 ){
        sleep(3);
        printf(&quot;PPID is %d,i=%d\n&quot;,getpid(),i);
    }else{
        perror(&quot;fork error\n&quot;);
        exit(-1);
    }
    printf(&quot;hello&quot;);
    wait(pid);
    //system(&quot;ps -o pid,ppid,state,tty,command&quot;);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_3">4、vfork</h4>

<p>任务描述:</p>

<ul>
<li>用vfork函数创建子进程,子进程创建一个for循环,每次sleep 1s再打印输出子进程的pid和自加变量i的值</li>
<li>父进程sleep 3s,再打印输出父进程的pid,以及自加变量i的值</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
int main(void){
    int i;
    pid_t pid;
    pid=vfork();
    if(pid==0){
        for(i=1;i&lt;10;i++){
            sleep(1);
            printf(&quot;process ID %d,i=%d\n&quot;,getpid(),i);
        }
        exit(0);
    }
    else{
        sleep(3);
        printf(&quot;PPID is %d,i=%d\n&quot;,getpid(),i);
        wait(pid);
    //system(&quot;ps -o pid,ppid,state,tty,command&quot;);
    }  
    return 0;
}
</code></pre>

<p><strong>运行程序可以看出使用vfork是先执行子进程再执行父进程的.</strong></p>
</blockquote>

<h4 id="toc_4">5、clone函数</h4>

<p>任务描述：</p>

<ul>
<li>主进程创建一个全局变量variable，并赋予初始值9，打印输出当前variable值</li>
<li>用clone函数创建子进程，clone的标志为CLONE_VM，CLONE_FILES,在子进程的函数do_something中将变量variable值修改为42</li>
<li>在主进程中sleep 3s，再打印输出variable值</li>
</ul>

<p>相关知识：<br/>
　　clone 函数功能强大,带了众多参数,因此由他创建的进程要比前面 2 种方法要复杂。clone 可以让你有选择性的继承父进程的资源,你可以选择想 vfork 一样和父进程共享一个虚存空间,从而使创造的是线程,你也可以不和父进程共享,你甚至可以选择创造出来的进程和父进程不再是父子关系,而是兄弟关系。函数的结构int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);这里 fn 是函数指针,我们知道进程的 4 要素,这个就是指向程序的指针,就是所谓的“剧本&quot;, child_stack 明显是为子进程分配系统堆栈空间(在 linux 下系统堆栈空间是 2页面,就是 8K 的内存,其中在这块内存中,低地址上放入了值,这个值就是进程控制块 task_struct 的值),flags 就是标志用来描述你需要从父进程继承那些资源, arg 就是传给子进程的参数)。下面是 flags 可以取的值：</p>

<table>
<thead>
<tr>
<th>CLONE_PARENT</th>
<th>创建的子进程的父进程是调用者的父进程,新进程与创建它的进程成了“兄弟”而不是“父子”</th>
</tr>
</thead>

<tbody>
<tr>
<td>CLONE_FS</td>
<td>子进程与父进程共享相同的文件系统,包括 root、当前目录、umask</td>
</tr>
<tr>
<td>CLONE_FILES</td>
<td>子进程与父进程共享相同的文件描述符(file descriptor)表</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>在新的 namespace 启动子进程,namespace 描述了进程的文件hierarchy</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>子进程与父进程共享相同的信号处理(signal handler)表</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>若父进程被 trace,子进程也被 trace</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>父进程被挂起,直至子进程释放虚拟内存资源</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>子进程与父进程运行于相同的内存空间</td>
</tr>
<tr>
<td>CLONE_PID</td>
<td>子进程在创建时 PID 与父进程一致</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>Linux 2.4 中增加以支持 POSIX 线程标准,子进程与父进程共享相同的线程群</td>
</tr>
</tbody>
</table>

<p>main.c:</p>

<blockquote>
<pre><code>#define _GNU_SOURCE
#define childstack 1000
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;sched.h&gt;
int variable=9;
void *stack;
int fn(){
    variable=42;
    free(stack);
    exit(1);
}
int main(void){
    void *stack;
    stack=malloc(childstack);
    printf(&quot;The variable was %d\n&quot;,variable);
    clone(&amp;fn,stack + childstack,CLONE_VM|CLONE_FILES,NULL);
    sleep(3);
    printf(&quot;in child process\n&quot;);
    printf(&quot;The variable is now %d\n&quot;,variable);   
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_5">6.WIFEXIED宏</h4>

<p>任务描述：</p>

<ul>
<li>子进程输出pid后，用exit函数结束，参数为3</li>
<li>父进程调用wait收集子进程退出状态</li>
<li>调用宏WIFEXITED（status）来查看子进程是否为正常输出</li>
<li>在主进程中sleep 3s ，再打印输出variable值</li>
<li>当WIFEXITED返回非0值时，用宏WEXITSTATUS来提取子进程的返回值</li>
</ul>

<p>相关知识：<br/>
　　进程一旦调用了 wait,就立即阻塞自己,由 wait 自动分析是否当前进程的某个子进程已经退出,如果让它找到了这样一个已经变成僵尸的子进程,wait 就会收集这个子进程的信息,并把它彻底销毁后返回;如果没有找到这样一个子进程,wait 就会一直阻塞在这里,直到有一个出现为止。<br/>
　　参数 status 用来保存被收集进程退出时的一些状态,它是一个指向 int 类型的指针。但如果我们对这个子进程是如何死掉的毫不在意,只想把这个僵尸进程消灭掉,(事实上绝大多数情况下,我们都会这样想),我们就可以设定这个参数为 NULL,就象下面这样:pid = wait(NULL);<br/>
　　如果成功,wait 会返回被收集的子进程的进程 ID,如果调用进程没有子进程,调用就会失败,此时 wait 返回-1,同时 errno 被置为 ECHILD。<br/>
参数 status:<br/>
　　如果参数 status 的值不是 NULL,wait 就会把子进程退出时的状态取出并存入其中,这是一个整数值(int),指出了子进程是正常退出还是被非正常结束的(一个进程也可以被其他进程用信号结束,我们将在以后的文章中介绍),以及正常结束时的返回值,或被哪一个信号结束的等信息。由于这些信息被存放在一个整数的不同二进制位中,所以用常规的方法读取会非常麻烦,人们就设计了一套专门的宏(macro)来完成这项工作:<br/>
　　①WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的,如果是,它会返回一个非零值(请注意,虽然名字一样,这里的参数 status 并不同于 wait 唯一的参数---指向整数的指针 status,而是那个指针所指向的整数,切记不要搞混了)<br/>
　　②WEXITSTATUS(status) 当 WIFEXITED 返回非零值时,我们可以用这个宏来提取子进程的返回值,如果子进程调用 exit(5),WEXITSTATUS(status) 就会返回 5;如果子进程调用 exit(7),WEXITSTATUS(status)就会返回 7。请注意,如果进程不是正常退出的,也就是说, WIFEXITED 返回 0,这个值就毫无意义。<br/>
main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
int main(){
    pid_t pid;
    pid=fork();
    int status;
    if(pid==0){
        printf(&quot;This is child process with pid of %d\n&quot;,getpid());
        exit(3);
    }
    else{
        pid=wait(&amp;status);
        sleep(3);
    if(WIFEXITED(status)!=0)
        printf(&quot;the child process %d exit normally\n&quot;,pid);
    if(WEXITSTATUS(status)==3)
        printf(&quot;the return code is %d\n&quot;,WEXITSTATUS(status));
    }
   return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_6">7.waitpid函数</h4>

<p>任务描述：</p>

<ul>
<li>子进程sleep 10s，父进程非阻塞等待子进程结束</li>
<li>收到子进程结束消息后结束进程，否则给予输出提示未收到子进程结束消息</li>
</ul>

<p>相关知识：<br/>
pid_t waitpid(pid_t pid,int *status,int options)<br/>
pid:<br/>
　　从参数的名字 pid 和类型 pid_t 中就可以看出,这里需要的是一个进程 ID。但当pid 取不同的值时,在这里有不同的意义。pid&gt;0 时,只等待进程 ID 等于 pid 的子进程,不管其它已经有多少子进程运行结束退出了,只要指定的子进程还没有结束,waitpid 就会一直等下去。<br/>
　　pid=-1 时,等待任何一个子进程退出,没有任何限制,此时 waitpid 和 wait 的作用一模一样。<br/>
　　pid=0 时,等待同一个进程组中的任何子进程,如果子进程已经加入了别的进程组,waitpid 不会对它做任何理睬。<br/>
　　pid&lt;-1 时,等待一个指定进程组中的任何子进程,这个进程组的 ID 等于 pid 的绝对值。<br/>
options:<br/>
　　options 提供了一些额外的选项来控制 waitpid,目前在 Linux 中只支持WNOHANG 和 WUNTRACED 两个选项,这是两个常数,可以用&quot;|&quot;运算符把它们连接起来使用,比如:ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);如果我们不想使用它们,也可以把 options 设为 0,如:ret=waitpid(-1,NULL,0);如果使用了 WNOHANG 参数调用 waitpid,即使没有子进程退出,它也会立即返回,不会像 wait 那样永远等下去。<br/>
返回值和错误:<br/>
　　当正常返回的时候,waitpid 返回收集到的子进程的进程 ID;<br/>
　　如果设置了选项 WNOHANG,而调用中 waitpid 发现没有已退出的子进程可收集,则返回 0;<br/>
　　如果调用中出错,则返回-1,这时 errno 会被设置成相应的值以指示错误所在;<br/>
　　当 pid 所指示的子进程不存在,或此进程存在,但不是调用进程的子进程,waitpid 就会出错返回,这时 errno 被设置为 ECHILD; </p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/wait.h&gt;
int main(void){
    int pr;
    pid_t pid;
    pid=fork();
    if(pid==0){
        printf(&quot;This is child, pid=%d. Sleeping...\n&quot;,getpid());
        sleep(10);
        exit(1);
    }
    else{ 
        do{
            pr=waitpid(pid,NULL,WNOHANG);//没有子进程退出,它也会立即返回,不会像 wait 那样永远等下去
            if(pr==0){
                printf(&quot;No child exited\n&quot;);
                sleep(1);
            } 
        }while(pr==0);
        if(pid==pr)
        printf(&quot;successfully get child %d\n&quot;,pid);
    }
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_7">8._exit函数</h4>

<p>任务描述：</p>

<ul>
<li>第一个程序用printf函数先后输出两句话，用exit（0）结束进程</li>
<li>第二个程序输出同第一个程序，用_exit（0）结束进程</li>
</ul>

<p>相关知识：<br/>
　　①exit 系统调用带有一个整数类型的参数 status,我们可以利用这个参数传递进程结束时的状态,比如说,该进程是正常结束的,还是出现某种意外而结束的,一般来说,0 表示没有意外的正常结束;其他的数值表示出现了错误,进程非正常结束。我们在实际编程时,可以用 wait 系统调用接收子进程的返回值,从而针对不同的情况进行不同的处理。<br/>
　　②exit 和_exit 作为系统调用而言,_exit 和 exit 是一对孪生兄弟。这种区别主要体现在它们在函数库中的定义。_exit 在 Linux 函数库中的原型是:</p>

<blockquote>
<p>　　  #include &quot;unistd.h&quot;<br/>
　　  void _exit(int status);</p>
</blockquote>

<p>　　exit 比较一下,exit()函数定义在 stdlib.h 中,而_exit()定义在 unistd.h 中,从名字上看,stdlib.h 似乎比 unistd.h 高级一点,那么,它们之间到底有什么区别呢?<br/>
　　_exit()函数的作用最为简单:直接使进程停止运行,清除其使用的内存空间,并销毁其在内核中的各种数据结构;exit()函数则在这些基础上作了一些包装,在执行退出之前加了若干道工序,也是因为这个原因,有些人认为 exit 已经不能算是纯粹的系统调用. exit()函数与_exit()函数最大的区别就在于 exit()函数在调用 exit 系统调用之前要检查文件的打开情况,把文件缓冲区中的内容写回文件,就是“清理 I/O 缓冲”.在Linux 的标准函数库中,有一套称作“高级 I/O”的函数,我们熟知的 printf()、fopen()、fread()、fwrite()都在此列,它们也被称作“缓冲I/O(buffered I/O)”,其特征是对应每一个打开的文件,在内存中都有一片缓冲区,每次读文件时,会多读出若干条记录,这样下次读文件时就可以直接从内存的缓冲区中读取,每次写文件的时候,也仅仅是写入内存中的缓冲区,等满足了一定的条件(达到一定数量,或遇到特定字符,如换行符\n 和文件结束符 EOF),再将缓冲区中的内容一次性写入文件,这样就大大增加了文件读写的速度,但也为我们编程带来了一点点麻烦。如果有一些数据,我们认为已经写入了文件,实际上因为没有满足特定的条件,它们还只是保存在缓冲区内,这时我们用_exit()函数直接将进程关闭,缓冲区中的数据就会丢失,反之,如果想保证数据的完整性,就一定要使用 exit()函数。<br/>
main1.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
int main(void){
    printf(&quot;hello\n&quot;);
    printf(&quot;fuck&quot;);
    exit(0);
    return 0;
}
</code></pre>

<p>main2.c:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
int main(void){
    printf(&quot;hello\n&quot;);
    printf(&quot;fuck&quot;);
    _exit(0);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_8">9.exec函数族的使用</h4>

<p>任务描述：</p>

<ul>
<li>通过exec函数族的6个函数列出当前文件夹下的所有目录和文件</li>
<li>execl、execlp、execle、execv、execvp、execve</li>
</ul>

<p>相关知识：<br/>
①exec 函数族说明<br/>
　　fork()函数用于创建一个子进程,该子进程几乎复制了父进程的全部内容,但是,这个新创建的进程如何执行呢?exec 函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件,并用它来取代原调用进程的数据段、代码段和堆栈段,在执行完之后,原调用进程的内容除了进程号外,其他全部被新的进程替换了。另外,这里的可执行文件既可以是二进制文件,也可以是Linux 下任何可执行的脚本文件。<br/>
    在 Linux 中使用 exec 函数族主要有两种情况:<br/>
　　● 当进程认为自己不能再为系统和用户做出任何贡献时,就可以调用 exec 函数族中的任意一个函数让自己重生。<br/>
　　● 如果一个进程想执行另一个程序,那么它就可以调用 fork()函数新建一个进程,然后调用 exec 函数族中的任意一个函数,这样看起来就像通过执行应用程序而产生了一个新进程(这种情况非常普遍)。<br/>
②exec 函数族语法<br/>
　　实际上,在 Linux 中并没有 exec()函数,而是有 6 个以 exec 开头的函数,它们之间的语法有细微差别,本书在后面会详细讲解。exec 函数族成员函数语法：</p>

<blockquote>
<pre><code>int execl(const char *path, const char *arg, ...)
int execv(const char *path, char *const argv[])
int execle(const char *path, const char *arg, ..., char *const envp[])
int execve(const char *path, char *const argv[], char *const envp[])
int execlp(const char *file, const char *arg, ...)
int execvp(const char *file, char *const argv[])
</code></pre>
</blockquote>

<p>这 6 个函数在函数名和使用语法的规则上都有细微的区别,下面就从可执行文件查找方式、参数传递方式及环境变量这几个方面进行比较.<br/>
　　● 查找方式。读者可以注意到,表 2 中的前 4 个函数的查找方式都是完整的文件目录路径,而最后两个函数(也就是以 p 结尾的两个函数)可以只给出文件名,系统就会自动按照环境变量“$PATH”所指定的路径进行查找。<br/>
　　● 参数传递方式。exec 函数族的参数传递有两种方式:一种是逐个列举的方式,而另一种则是将所有参数整体构造指针数组传递。在这里是以函数名的第 5 位字母来区分的,字母为“l”(list)的表示逐个列举参数的方式,其语法为 const char <em>arg;字母为“v”(vertor)的表示将所有参数整体构造指针数组传递,其语法为 char</em>const argv[]。读者可以观察 execl()、execle()、execlp()的语法与 execv()、execve()、execvp()的区别,它们的具体用法在后面的实例讲解中会具体说明。这里的参数实际上就是用户在使用这个可执行文件时所需的全部命令选项字符串(包括该可执行程序命令本身)。要注意的是,这些参数必须以 NULL 结束。<br/>
　　● 环境变量。exec 函数族可以默认系统的环境变量,也可以传入指定的环境变量。这里以“e”(environment)结尾的两个函数 execle()和 execve()就可以在 envp[]中指定当前进程所使用的环境变量。</p>

<p>　　事实上,这 6 个函数中真正的系统调用只有 execve(),其他 5 个都是库函数,它们最终都会调用 execve()这个系统调用。在使用 exec 函数族时,一定要加上错误判断语句。exec 很容易执行失败,其中最常见的原因有:<br/>
　　● 找不到文件或路径,此时 errno 被设置为 ENOENT。<br/>
　　● 数组 argv 和 envp 忘记用 NULL 结束,此时 errno 被设置为 EFAUL。<br/>
　　● 没有对应可执行文件的运行权限,此时 errno 被设置为 EACCES。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
int main(int argc, char *argv[]){
    char *env[] = {&quot;/bin/ls&quot;,&quot;ls&quot;, &quot;-a&quot;, NULL};
    pid_t pid;
    pid=fork();
    if( fork() == 0 ){
        printf(&quot;1------------execl------------\n&quot; );
        if( execl( &quot;/bin/ls&quot;, &quot;ls&quot;,&quot;-a&quot;, NULL ) == -1 ){
            perror( &quot;execl error &quot; );
            exit(1);
        }
    }
    wait(pid);
    if( fork() == 0 ){
        printf(&quot;2------------execlp------------\n&quot;);
        if( execlp( &quot;ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL ) &lt; 0 ){
            perror( &quot;execlp error &quot; );
            exit(1);
        }
    }
    wait(pid);
    if( fork() == 0 ){
        printf(&quot;3------------execle------------\n&quot;);
        if( execle(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, NULL, NULL) == -1 ){
            perror(&quot;execle error &quot;);
            exit(1);
        }
    }
    wait(pid);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_9">10.exec函数族的使用</h4>

<p>任务描述：</p>

<ul>
<li>修改task9的代码，调用所给程序，打印输出所有命令行参数和所有环境字符串</li>
</ul>

<p>相关知识：<br/>
　　每个程序都有一个环境变量表,和命令行参数表一样,环境变量表也是一个指针数组。<br/>
　　extern char ** environ<br/>
echoall.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;unistd.h&quot;
#include &lt;stdlib.h&gt;
int main(int argc, char *argv[]){
    int i;
    char **ptr;
    extern char **environ;
    for(i=0;i&lt;argc;i++)
        printf(&quot;argv[%d]: %s\n&quot;, i, argv[i]);
        for(ptr=environ; *ptr!=0; ptr++)
        printf(&quot;%s\n&quot;,*ptr);
    exit(0);
}
</code></pre>
</blockquote>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
int main(int argc,char**argv,char**env){
    execle(&quot;./echoall&quot;,&quot;./echoall&quot;, &quot;myarg1&quot;, &quot;MY ARG2&quot;,NULL,env);
    fprintf(stderr,&quot;%s\n&quot;,strerror(errno));
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_10">11.exec函数族使用</h4>

<p>任务描述：</p>

<ul>
<li>创建hello.c用于输出环境变量</li>
<li>父进程中创建两个环境变量AA=11，BB=22</li>
<li>子进程输出父进程传递过来的环境变量</li>
</ul>

<p>hello.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
int main(int argc,char *argv[]){
    int i;
    char **ptr;
    extern char **environ;
    for(ptr = environ; *ptr !=0; ptr ++)
        printf(&quot;%s\n&quot;,*ptr);
        exit(0);
    }
</code></pre>
</blockquote>

<p>main.c:</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;unistd.h&quot;
int main(){
    char *ps_envp[]={&quot;AA=11&quot;,&quot;BB=22&quot;,NULL};
    pid_t pid;
    pid=fork();
    if(pid&lt;0){
            printf(&quot;error!\n&quot;);
            return -1;
    }
   if(pid==0){
        printf(&quot;Entering main ...\n&quot;);
        printf(&quot;hello pid=%d\n&quot;,getpid());
        if(execle(&quot;./hello&quot;,&quot;hello&quot;,NULL,ps_envp)==-1){
            printf(&quot;error\n&quot;);
            exit(0);
        }
    }
　　 ptr=wait(NULL);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_11">12.僵死进程</h4>

<p>任务描述：</p>

<ul>
<li>编写一个僵死进程</li>
<li>用system命令执行ps命令验证该进程是僵死进程</li>
</ul>

<p>相关知识：<br/>
　　<strong><em>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</em></strong><br/>
　　产生原因：<strong><em>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理,这是每个子进程在结束时都要经过的阶段。</em></strong>父进程尚未对已终止子进程调用 wait 函数善后,尚留存进程 ID、终止状态等信息,只有等到父进程处理或父进程结束被 init 领养才能释放资源。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。<br/>
　　waitpid 返回终止子进程的进程 ID。并将该子进程的终止状态存放在有 status 指向的存储单元中。</p>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &quot;unistd.h&quot;
#include &lt;stdlib.h&gt;
int main(){
    pid_t pid;
    pid=fork();
    if(pid==0){ 
        printf(&quot;create a zoombie\n&quot;);
        exit(0);
    }
    printf(&quot;pid is %d\n&quot;,getpid());
    //system(&quot;ps a&quot;);
    system(&quot;ps -o pid,ppid,state,tty,command&quot;);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_12">13. 僵死进程的避免</h4>

<p>任务描述：</p>

<ul>
<li>调用fork函数两次以避免僵死进程</li>
</ul>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &quot;unistd.h&quot;
#include &lt;stdlib.h&gt;
int main(){
    pid_t pid;
    pid=fork();
    if(pid==0) { 
        printf(&quot;create a son\n&quot;);
        pid=fork();
        if(pid&gt;0)
            exit(0);  
            printf(&quot;create a grandson\n&quot;);
        sleep(2);
        printf(&quot;parent pid= %d\n&quot;,getppid());
        exit(0);
    }
    return 0;
}
</code></pre>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql初始化]]></title>
    <link href="weijing24.github.io/15038316518471.html"/>
    <updated>2017-08-27T19:00:51+08:00</updated>
    <id>weijing24.github.io/15038316518471.html</id>
    <content type="html"><![CDATA[
<p>/usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data &amp;</p>

<h1 id="toc_0">开启mysql进程</h1>

<p>/bin/sh /usr/local/sina_mobile/mysql/bin/mysqld_safe --defaults-file=/data1/mysql3367/my3367.cnf &amp;</p>

<h1 id="toc_1">初始化密码</h1>

<p>/usr/local/sina_mobile/mysql/bin/mysqladmin -u root password &#39;221.179.193.164&#39; -S /tmp/mysql3367.sock</p>

<h1 id="toc_2">备份</h1>

<p>/usr/local/sina_mobile/mysql/bin/mysqldump -uroot -pkSwD3Ji#Gm8B&amp;0U$ -S /tmp/mysql_10191.sock --all-databases --where &quot;1=1 limit 100&quot; --lock-all-tables --events &gt; 10191.dump</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nagios安装]]></title>
    <link href="weijing24.github.io/15038316187109.html"/>
    <updated>2017-08-27T19:00:18+08:00</updated>
    <id>weijing24.github.io/15038316187109.html</id>
    <content type="html"><![CDATA[
<p>　　纯粹nagios的安装是很简单的，但是我们需要看他的web界面，这需要apache+php的结合才行。</p>

<h3 id="toc_0">基础环境安装</h3>

<p>　　需要先装apr和apr-util再装apache，以下是编译参数</p>

<blockquote>
<pre><code>./configure --prefix=/usr/local/sina_mobile/apr --enable-shared &amp;&amp; make -j4 &amp;&amp; make install
./configure --prefix=/usr/local/sina_mobile/apr-util --with-apr=/usr/local/sina_mobile/apr &amp;&amp; make -j4 &amp;&amp; make install
./configure --prefix=/usr/local/sina_mobile/apache --with-apr=/usr/local/sina_mobile/apr/bin/apr-1-config --with-apr-util=/usr/local/sina_mobile/apr-util/bin/apu-1-config --enable-modules=all --enable-mods-shared=all --enable-http --enable-dav --enable-so　　
</code></pre>
</blockquote>

<p>　　apache安装完毕后在安装php,因为php使用dso模式需要有apache的apxs</p>

<blockquote>
<pre><code>./configure --with-apxs2=/usr/local/sina_mobile/apache/bin/apxs --prefix=/usr/local/sina_mobile/php568 --with-config-file-path=/usr/local/sina_mobile/php568/lib --with-config-file-scan-dir=/usr/local/sina_mobile/php568/lib/php.d --with-curl --with-mhash --with-xmlrpc --with-tidy --with-ldap --with-pear --with-gdbm --with-openssl --with-openssl-dir=/usr/lib64 --with-gettext --with-zlib --with-zlib-dir --with-libxml-dir --with-mcrypt --with-iconv --with-gd=/usr/local/sina_mobile/gd210 --with-jpeg-dir=/usr/local/sina_mobile/jpeg --with-png-dir=/usr/local/sina_mobile/libpng --with-freetype-dir --with-xpm-dir=/usr/lib64 --with-mysql=/usr/local/sina_mobile/mysql --with-mysqli=/usr/local/sina_mobile/mysql/bin/mysql_config --with-pdo-mysql=/usr/local/sina_mobile/mysql --enable-fpm --enable-mbstring --enable-zip --enable-soap --enable-sysvsem --enable-shmop --enable-sockets --enable-exif --enable-ftp --enable-gd-native-ttf --enable-bcmath --enable-pcntl --enable-maintainer-zts
</code></pre>
</blockquote>

<p>　　到此，基础环境就已经安装好了。</p>

<h3 id="toc_1">nagios依赖包安装</h3>

<p>　　安装nagios还需要安装它的配套的插件nagios-plugins，因为nagios自身能做的不多，主要是靠插件实现报警的。在安装nagios和nagios的插件前需要安装一下几个基础包：</p>

<blockquote>
<p>　　net-snmp net-snmp-devel net-snmp-utils </p>
</blockquote>

<p>　　然后安装nrpe</p>

<blockquote>
<pre><code>./configure --prefix=/usr/local/sina_mobile/nagios --enable-ssl --enable-command-args --with-nrpe-user=nagios --with-nrpe-group=nagios --with-nagios-user=nagios --with-nagios-group=nagios &amp;&amp; make -j4 &amp;&amp; make install &amp;&amp; make install-init &amp;&amp; make install-commandmode &amp;&amp; make install-config make install-webconf
</code></pre>
</blockquote>

<p>　　安装nagios</p>

<blockquote>
<pre><code>./configure --prefix=/usr/local/sina_mobile/nagios --with-nagios-user=nagios --with-nagios-group=nagios &amp;&amp; make -j4 &amp;&amp; make install
</code></pre>
</blockquote>

<p><strong>注意：如果apache是使用源码安装的话，我们在执行make install-webconf会报错。我们只需要把sample-config/httpd.conf复制到/usr/local/apache2/conf/下，并重命名为nagios.conf即可。在这apache是安装到/usr/local/apache2下。如下：</strong><br/>
<strong>cp sample-config/httpd.conf /usr/local/sina_mobile/apache/conf/nagios.conf</strong><br/>
以上操作之后，我们还需要在/usr/local/apache/conf/httpd.conf 文件中添加 Include conf/nagios.conf。如下：<br/>
<img src="media/15038316187109/15038316335248.jpg" alt=""/><br/>
　　安装nagios-plugins</p>

<blockquote>
<pre><code>./configure --prefix=/usr/local/sina_mobile/nagios --with-nagios-user=nagios --with-nagios-group=nagios --enable-shared --enable-perl-modules &amp;&amp; make -j4 &amp;&amp; make install
</code></pre>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nagios配置]]></title>
    <link href="weijing24.github.io/15038315676757.html"/>
    <updated>2017-08-27T18:59:27+08:00</updated>
    <id>weijing24.github.io/15038315676757.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15038315676757/15038315831682.jpg" alt=""/></p>

<p>通过上图，我们可以很明显的看到所有的配置文件。下面来介绍每个配置文件具体作用。如下：<br/>
cgi.cfg用于控制CGI访问的配置文件。<br/>
htpasswd.users用于存放nagios管理员用户名和密码的文件。<br/>
nagios.cfg是nagios主配置文件，所有的cfg配置文件（外部调用除外）必须都在此文件中引用cfg配置文件才能生效。<br/>
resource.cfg变量定义文件，又称为资源文件。该文件中定义的变量，可以被其他配置文件引用，如$USER1$。<br/>
objects是一个目录，此目录下的文件主要用于定义nagios的监控对象。<br/>
commands.cfg是nagios监控命令的定义文件，其中定义的命令可以被其他配置文件引用。<br/>
contacts.cfg是定义nagios监控对象出现故障时，通知的联系人和联系人组的配置文件。<br/>
localhost.cfg是定义监控本地主机的配置文件。<br/>
templates.cfg是定义主机和服务的一个模板配置文件。<br/>
timeperiods.cfg是定义nagios监控时间段的配置文件。<br/>
services.cfg是存放具体被监控服务的相关配置内容。该配置文件默认是不存在的，需要自己手工建立，并且要建立在services目录下。同时还需要在nagios.cfg文件指定services目录。如下：<br/>
<img src="media/15038315676757/15038315931128.jpg" alt=""/><br/>
hosts.cfg存放具体被监控的主机相关配置。该配置文件默认是不存在的，需要自己手工建立，并且要建立在hosts目录下。同时还需要在nagios.cfg文件指定hosts目录。与services.cfg使用方法相同。</p>

<h3 id="toc_0">nagios配置文件之间的关系</h3>

<p>在nagios的配置过程中涉及到定义有：主机、主机组，服务、服务组，联系人、联系人组，监控时间，监控命令等。从这些定义可以看出，nagios各个配置文件之间是互为关联、彼此引用的。</p>

<p>要成功配置出一台nagios监控系统，必须要弄清楚各个配置文件之间依赖与被依赖的关系，最重要的有四点：<br/>
第一：定义监控哪些主机、主机组、服务和服务组。<br/>
第二：定义这个监控要用什么命令实现。<br/>
第三：定义监控的时间段。<br/>
第四：定义主机或服务出现问题时要通知的联系人和联系人组。</p>

<h4 id="toc_1">cgi.cfg文件介绍</h4>

<p>cgi.cfg文件是用来控制nagios的相关cgi脚本。如果想在nagios的web监控界面执行相关的cgi脚本，例如重启nagios进程、关闭nagios通知、停止nagios主机检测等，这时就需要配置cgi.cfg文件。</p>

<h4 id="toc_2">nagios.cfg文件介绍</h4>

<p>nagios.cfg是nagios的主配置文件，默认的路径为/usr/local/nagios/etc/nagios.cfg。所有的对象配置文件都必须在这个文件中进行定义才能发挥其作用，这里只需将对象配置文件在nagios.cfg文件中引用即可。<br/>
<img src="media/15038315676757/15038316035833.jpg" alt=""/></p>

<p>说明:<br/>
　　<strong>log_file=/usr/local/sina_mobile/nagios/var/nagios.log</strong><br/>
　　log_file变量用于定义nagios在何处创建其日志文件。如果你使用了nagios日志轮询功能，那么nagios将在每小时、每天、每周或每月对日志进行轮询。</p>

<p>　　<strong>cfg_file=/usr/local/nagios/etc/objects/commands.cfg</strong><br/>
　　用于定义nagios监控命令的配置文件。<br/>
　　cfg_file变量用来引用对象配置文件，如果有更多的对象配置文件，我们只需在nagios.cfg文件中依次添加即可。对象配置文件中一般包含主机、主机组、联系人、联系人组、服务、命令等对象的定义</p>

<p>　　<strong>cfg_dir=/usr/local/sina_mobile/nagiosql/etc/services</strong><br/>
　　cfg_dir变量用于引用一个目录里包含的所有对象配置文件。所有在这个目录下的且以.cfg为后缀名的文件将被作为对象配置文件来处理。另外，nagios将会递归该目录下的子目录并处理其子目录下的全部配置文件。你也可以把配置放入不同的目录并且用cfg_dir=语句来指向每个待处理的目录</p>

<p>　　<strong>cfg_file=/usr/local/sina_mobile/nagiosql/etc/contacts.cfg</strong><br/>
　　用于引用nagios联系人的配置文件。</p>

<p>　　<strong>cfg_file=/usr/local/sina_mobile/nagiosql/etc/timeperiods.cfg</strong><br/>
　　用于引用nagios监控时段的配置文件。</p>

<p>　　<strong>cfg_file=/usr/local/sina_mobile/nagiosql/etc/templates.cfg</strong><br/>
　　用于引用nagios监控对象的模版文件。</p>

<p>　　<strong>cfg_file=/usr/local/sina_mobile/nagiosql/etc/localhost.cfg</strong><br/>
　　用于引用nagios监控本地(Linux)主机的配置文件。</p>

<p>　　<strong>resource_file=/usr/local/sina_mobile/nagios/etc/resource.cfg</strong><br/>
　　resource_file变量用于存储用户定义的宏，定义nagios资源配置文件，可以在nagios.cfg中定义多个资源文件。</p>

<p>　　<strong>status_file=/usr/local/sina_mobile/nagios/var/status.dat</strong><br/>
　　status_file变量用于定义nagios的状态文件，此文件用于保存nagios当前的状态、宕机信息等。它会在每次nagios重新启动的时候被清空删除。</p>

<p>　　<strong>status_update_interval=10</strong><br/>
　　该变量用于定义状态文件（即status.dat）的更新时间间隔，单位是秒，最小更新间隔是1秒，默认是10秒。</p>

<p>　　<strong>check_external_commands=1</strong><br/>
　　该变量用于设置是否允许nagios在web监控界面运行cgi命令，也就是是否允许nagios在web界面下执行重启nagios、停止主机、服务检查等操作。其中1表示允许，0表示不允许。</p>

<p>　　<strong>command_file=/usr/local/sina_mobile/nagios/var/rw/nagios.cmd</strong><br/>
　　定义nagios用来检查外部命令请求的文件。这个文件同样也是用户操作提交与CGI命令写入的地方，所以这个文件必须对于相关服务可写，一般是针对Apache的宿主用户可写。并且注意，这个文件所在的目录的权限必须被Apache可写，而不单指这文件，因为这个文件在工作当中是频繁被写入和删除的。</p>

<p>　　<strong>lock_file=/usr/local/sina_mobile/nagios/var/nagios.lock</strong><br/>
　　定义nagios运行时用来保存它的PID文件。</p>

<p>　　<strong>temp_file=/usr/local/sina_mobile/nagios/var/nagios.tmp</strong><br/>
　　定义nagios临时文件路径。它将在nagios运行时不停地被建立、使用和删除。</p>

<p>　　<strong>log_rotation_method=d</strong><br/>
　　定义nagios的日志轮询方式，默认是每天轮询。值为n表示none，不做轮询。值为h表示hourly，每小时轮询一次（每小时的开始）。值为d表示daily，每天轮询一次（每天的午夜）。值为w表示weekly，每周轮询一次（每周六的晚上）。值为m表示monthly，每月轮询一次（每上个月的最后一天的午夜）。</p>

<p>　　<strong>log_archive_path=/usr/local/sina_mobile/nagios/var/archives</strong><br/>
　　定义nagios日志的归档路径。</p>

<p>　　<strong>command_check_interval=10s</strong><br/>
　　该变量用于定义nagios对外部命令检测的间隔，默认为10秒。如果这个数值不加上单位的话，默认单位为分钟。例如1就是表示1分钟，nagios每分钟检测一次。</p>

<p>　　<strong>service_check_timeout=60</strong><br/>
　　定义服务检测的超时时间，默认为60秒。如果服务检查时间超过所定义的时间，则显示为CRITICAL状态。</p>

<p>　　<strong>host_check_timeout=30</strong><br/>
　　定义主机检测的超时时间，默认为30秒。若主机检查时间超过所定义的时间，则显示为CRITICAL状态。</p>

<p>　　<strong>event_handler_timeout=30</strong><br/>
　　定义事件处理最长时间，默认为30秒。若事件处理最长时间超出所定义的时间，则nagios会发出一条warning警告信息并记录到日志中。</p>

<p>　　<strong>notification_timeout=30</strong><br/>
　　定义通知信息发送的时间间隔，默认为30秒。</p>

<p>　　<strong>interval_length=60</strong><br/>
　　该变量用于定义nagios检测时间间隔的单位，默认值是60秒，即1分钟。也就是说在nagios中，检测时间间隔默认是以分钟为单位的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx、mysql、php等各编译参数查询]]></title>
    <link href="weijing24.github.io/15038315492978.html"/>
    <updated>2017-08-27T18:59:09+08:00</updated>
    <id>weijing24.github.io/15038315492978.html</id>
    <content type="html"><![CDATA[
<p>查看nginx编译参数：/usr/local/nginx/sbin/nginx -V</p>

<p>查看apache编译参数：cat /usr/local/apache2/build/config.nice</p>

<p>查看mysql编译参数：mysql<5.5  cat /usr/local/mysql/bin/mysqlbug | grep CONFIGURE_LINE<br/>
　　　　　　　　　　mysql>=5.5 cat /usr/local/mysql5.5/docs/INFO_BIN </p>

<p>查看php编译参数：/usr/local/php/bin/php -i | grep configure</p>

]]></content>
  </entry>
  
</feed>
