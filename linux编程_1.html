<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  linux编程 - 小菜鸡
  
  </title>
 <meta name="description" content="个人博客">
 <link href="atom.xml" rel="alternate" title="小菜鸡" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">小菜鸡</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 小菜鸡</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>容器</label></li>

          
            <li><a title="制作nginx和php的rpm包" href="15033225667618.html">制作nginx和php的rpm包</a></li>
          

      
        <li class="divider"></li>
        <li><label>web服务器</label></li>

          
            <li><a title="图解正向代理、反向代理、透明代理" href="15033223691311.html">图解正向代理、反向代理、透明代理</a></li>
          
            <li><a title="详解apache的allow和deny" href="15033200332645.html">详解apache的allow和deny</a></li>
          

      
        <li class="divider"></li>
        <li><label>linux编程</label></li>

          
            <li><a title="wait和waitpid详解" href="15033229130846.html">wait和waitpid详解</a></li>
          
            <li><a title="信号" href="15033227238921.html">信号</a></li>
          
            <li><a title="僵尸进程和孤儿进程" href="15033226512813.html">僵尸进程和孤儿进程</a></li>
          
            <li><a title="共享内存" href="15033226237472.html">共享内存</a></li>
          
            <li><a title="基于TCP的字符串传输程序" href="15033223148818.html">基于TCP的字符串传输程序</a></li>
          
            <li><a title="文件搜索" href="15033220404521.html">文件搜索</a></li>
          
            <li><a title="文件比较" href="15033218983068.html">文件比较</a></li>
          
            <li><a title="文件编辑" href="15033218793219.html">文件编辑</a></li>
          
            <li><a title="文件设置" href="15033218534320.html">文件设置</a></li>
          
            <li><a title="系统文件操作开发" href="15033218072587.html">系统文件操作开发</a></li>
          
            <li><a title="系统环境变量" href="15033217888989.html">系统环境变量</a></li>
          
            <li><a title="静态库和共享库开发" href="%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BC%80%E5%8F%91.html">静态库和共享库开发</a></li>
          

      
        <li class="divider"></li>
        <li><label>坑</label></li>

          
            <li><a title="<center>数据库非正常关闭导致无法启动问题</center>" href="15033220957416.html"><center>数据库非正常关闭导致无法启动问题</center></a></li>
          
            <li><a title="解决virtualbox安装增强工具失败的问题" href="15033217564988.html">解决virtualbox安装增强工具失败的问题</a></li>
          
            <li><a title="记一次ftp服务器搭建走过的坑" href="15033217230950.html">记一次ftp服务器搭建走过的坑</a></li>
          
            <li><a title="记一次mysql主从一致校验走过的坑" href="15033215794872.html">记一次mysql主从一致校验走过的坑</a></li>
          

      
        <li class="divider"></li>
        <li><label>日常运维</label></li>

          
            <li><a title="ubuntu mysql5.7源码安装" href="15033230940135.html">ubuntu mysql5.7源码安装</a></li>
          
            <li><a title="ubuntu php5.6源码安装" href="15033230316456.html">ubuntu php5.6源码安装</a></li>
          
            <li><a title="ubuntu下nginx的安裝" href="15033229668634.html">ubuntu下nginx的安裝</a></li>
          
            <li><a title="ubuntu安装php常见错误集锦" href="15033229497885.html">ubuntu安装php常见错误集锦</a></li>
          
            <li><a title="vim常用命令" href="15033229297218.html">vim常用命令</a></li>
          
            <li><a title="使用RAID进行磁盘管理" href="15033227857622.html">使用RAID进行磁盘管理</a></li>
          
            <li><a title="使用virt-manager创建和管理虚拟机" href="15033227559982.html">使用virt-manager创建和管理虚拟机</a></li>
          
            <li><a title="关于mysqld_safe" href="15033226078265.html">关于mysqld_safe</a></li>
          
            <li><a title="安装linux各种桌面环境" href="15033222846104.html">安装linux各种桌面环境</a></li>
          
            <li><a title="常用软件编译参数以及软件地址" href="15033222695994.html">常用软件编译参数以及软件地址</a></li>
          
            <li><a title="打造属于自己的vim利器" href="15033222443468.html">打造属于自己的vim利器</a></li>
          
            <li><a title="搭建本地yum源服务器" href="15033221654695.html">搭建本地yum源服务器</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>容器</span></li>
                        
                          <li><a title="制作nginx和php的rpm包" href="15033225667618.html">制作nginx和php的rpm包</a></li>
                        

                    
                      <li class="side-title"><span>web服务器</span></li>
                        
                          <li><a title="图解正向代理、反向代理、透明代理" href="15033223691311.html">图解正向代理、反向代理、透明代理</a></li>
                        
                          <li><a title="详解apache的allow和deny" href="15033200332645.html">详解apache的allow和deny</a></li>
                        

                    
                      <li class="side-title"><span>linux编程</span></li>
                        
                          <li><a title="wait和waitpid详解" href="15033229130846.html">wait和waitpid详解</a></li>
                        
                          <li><a title="信号" href="15033227238921.html">信号</a></li>
                        
                          <li><a title="僵尸进程和孤儿进程" href="15033226512813.html">僵尸进程和孤儿进程</a></li>
                        
                          <li><a title="共享内存" href="15033226237472.html">共享内存</a></li>
                        
                          <li><a title="基于TCP的字符串传输程序" href="15033223148818.html">基于TCP的字符串传输程序</a></li>
                        
                          <li><a title="文件搜索" href="15033220404521.html">文件搜索</a></li>
                        
                          <li><a title="文件比较" href="15033218983068.html">文件比较</a></li>
                        
                          <li><a title="文件编辑" href="15033218793219.html">文件编辑</a></li>
                        
                          <li><a title="文件设置" href="15033218534320.html">文件设置</a></li>
                        
                          <li><a title="系统文件操作开发" href="15033218072587.html">系统文件操作开发</a></li>
                        
                          <li><a title="系统环境变量" href="15033217888989.html">系统环境变量</a></li>
                        
                          <li><a title="静态库和共享库开发" href="%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BA%93%E5%BC%80%E5%8F%91.html">静态库和共享库开发</a></li>
                        

                    
                      <li class="side-title"><span>坑</span></li>
                        
                          <li><a title="<center>数据库非正常关闭导致无法启动问题</center>" href="15033220957416.html"><center>数据库非正常关闭导致无法启动问题</center></a></li>
                        
                          <li><a title="解决virtualbox安装增强工具失败的问题" href="15033217564988.html">解决virtualbox安装增强工具失败的问题</a></li>
                        
                          <li><a title="记一次ftp服务器搭建走过的坑" href="15033217230950.html">记一次ftp服务器搭建走过的坑</a></li>
                        
                          <li><a title="记一次mysql主从一致校验走过的坑" href="15033215794872.html">记一次mysql主从一致校验走过的坑</a></li>
                        

                    
                      <li class="side-title"><span>日常运维</span></li>
                        
                          <li><a title="ubuntu mysql5.7源码安装" href="15033230940135.html">ubuntu mysql5.7源码安装</a></li>
                        
                          <li><a title="ubuntu php5.6源码安装" href="15033230316456.html">ubuntu php5.6源码安装</a></li>
                        
                          <li><a title="ubuntu下nginx的安裝" href="15033229668634.html">ubuntu下nginx的安裝</a></li>
                        
                          <li><a title="ubuntu安装php常见错误集锦" href="15033229497885.html">ubuntu安装php常见错误集锦</a></li>
                        
                          <li><a title="vim常用命令" href="15033229297218.html">vim常用命令</a></li>
                        
                          <li><a title="使用RAID进行磁盘管理" href="15033227857622.html">使用RAID进行磁盘管理</a></li>
                        
                          <li><a title="使用virt-manager创建和管理虚拟机" href="15033227559982.html">使用virt-manager创建和管理虚拟机</a></li>
                        
                          <li><a title="关于mysqld_safe" href="15033226078265.html">关于mysqld_safe</a></li>
                        
                          <li><a title="安装linux各种桌面环境" href="15033222846104.html">安装linux各种桌面环境</a></li>
                        
                          <li><a title="常用软件编译参数以及软件地址" href="15033222695994.html">常用软件编译参数以及软件地址</a></li>
                        
                          <li><a title="打造属于自己的vim利器" href="15033222443468.html">打造属于自己的vim利器</a></li>
                        
                          <li><a title="搭建本地yum源服务器" href="15033221654695.html">搭建本地yum源服务器</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>文件搜索</h1>

		<h4 id="toc_0">1、判断文件是否是目录文件</h4>

<p>任务描述：</p>

<ul>
<li>给出一个文件的绝对路径，判断该文件是否是目录文件</li>
<li>将文件的绝对路径做输入参数，打印信息表明该文件是否为目录</li>
</ul>

<p>相关知识：<br/>
S_ISDIR (st_mode) ：判断是否为目录</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
struct stat buf;
int main(int argc ,char *argv[]){
    if(argc!=2){
        perror(&quot;argc error\n&quot;);
        exit(1);
    }
    if(stat(argv[1],&amp;buf)!=0){
        perror(&quot;stat error\n&quot;);
        exit(1);
    }
    if(S_ISDIR(buf.st_mode))
        printf(&quot;it id a dir\n&quot;);
    else
        printf(&quot;it isn&#39;t a dir\n&quot;); 
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_1">2.列出指定目录下所有文件名</h4>

<p>任务描述：</p>

<ul>
<li>绝对路径名做输入参数，打印出该路径下所有文件名</li>
</ul>

<p>相关知识：<br/>
DIR* opendir (const char * path )　　　　　　<br/>
　　opendir()用来打开参数name 指定的目录, 并返回<strong>DIR*形态的目录流</strong>, 和open()类似, 接下来对目录的读取和搜索都要使用此返回值。返回值：成功则返回DIR* 型态的目录流, 打开失败则返回NULL。不用管DIR的内部结构是什么样的，只要知道要传给readdir()函数的参数就行了。<br/>
struct dirent *readdir(DIR *dir)：读取目录　　<br/>
　　它的参数是opendir函数返回的DIR*句柄，而该函数的<strong>返回值是struct dirent* 类型</strong>，这个结构体定义如下：</p>

<blockquote>
<pre><code>struct dirent {
    ino_t  d_ino;   /* inode number */
    off_t  d_off;   /* offset to the next dirent */
    unsigned short d_reclen;    /* length of this record */
    unsigned char  d_type;      /* type of file */
    char     d_name[256]; /* filename */    
};
    d_name存放的是文件的名字。
    Readdir返回指向下一个目录项的指针。
</code></pre>
</blockquote>

<p>main.c：</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
struct dirent *entry;
int main(int argc ,char *argv[]){
    char path[1024];
    DIR *dirptr=NULL;
    if(argc!=2){
        perror(&quot;argc error\n&quot;);
        exit(1);
    }
    if((dirptr=opendir(argv[1]))==NULL){
        perror(&quot;stat error\n&quot;);
        exit(1);
    }else{
        while(entry=readdir(dirptr)){
            if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)                 　　　　　　　　　　continue;//如果输入的是相对路径，不处理
            //sprintf(path,&quot;%s/%s&quot;,argv[1],entry-&gt;d_name);//输出绝对路径
                printf(&quot;%s\n&quot;,entry-&gt;d_name); 
        }
    closedir(dirptr);
    }  
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_2">3.列出指定目录下所有文件的绝对路径</h4>

<p>相关知识：</p>

<ul>
<li><p>绝对路径由指定目录的绝对路径加上文件的相对路径得到</p></li>
<li><p>int sprintf( char *buffer, const char *format, [ argument] … )：字符串格式化命令，主要功能是把格式化的数据写入某个字符串中　　　　</p></li>
</ul>

<p>　　　　buffer：char型指针，指向将要写入的字符串的缓冲区。</p>

<p>　　　　format：格式化字符串。</p>

<p>　　　　[argument]...：可选参数，可以是任何类型的数据。</p>

<p>　　　　返回值：字符串长度（strlen）</p>

<p>main.c：</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
struct dirent *entry;
int main(void){
    DIR *dirptr=NULL;
    char name[N];
    char buf[N];
    char path[N];
    printf(&quot;please input a path\n&quot;);
    fgets(name,N,stdin);//输入路径 
    int i=strlen(name);
    name[i-1]=&#39;\0&#39;;//将fgets最后的回车置零
    if((dirptr=opendir(name))==NULL){
        perror(&quot;your input dir is not existed\n&quot;);
        exit(1);
    }else{
        chdir(name);//切换到name这个目录
        getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
        while(entry=readdir(dirptr)){
            if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
                continue;//如果输入的是相对路径，不处理
            sprintf(path,&quot;%s/%s&quot;,buf,entry-&gt;d_name);//输出绝对路径
            printf(&quot;%s\n&quot;,path);  
        }
        closedir(dirptr);
    }
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_3">4.递归列出指定目录下的所有文件的绝对路径</h4>

<p>任务描述：</p>

<ul>
<li>输入绝对路径，输出该路径下所有文件及子目录下文件的绝对路径</li>
</ul>

<p>相关知识：</p>

<p>递归函数　　<br/>
　　一个过程(或函数)直接或间接调用自己本身,这种过程(或函数)叫递归过程(或函数)。<br/>
　　它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。用递归思想写出的程序往往十分简洁易懂。 <br/>
　　一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 <br/>
　　注意： <br/>
　　<strong>(1) 递归就是在过程或函数里调用自身;</strong> <br/>
　　<strong>(2) 在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口，否则将无限进行下去（死锁）。</strong></p>

<p><strong>在判断文件是目录文件后，递归调用函数遍历该子目录</strong></p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
struct dirent *entry;
void fun(char *pathname){
    DIR *dp;
    char buf[N],path[N];
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把相对路径变为绝对路径
    getcwd(buf,N);//获得输入的路径并把当前路径的绝对路径保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        sprintf(path,&quot;%s/%s&quot;,buf,entry-&gt;d_name);//输出绝对路径
        struct stat st;
        stat(path,&amp;st);
        if(S_ISDIR(st.st_mode))
            fun(path);
        else
            printf(&quot;%s\n&quot;,path);
    }
    closedir(dp);
}
int main(void){
    char name[N];
    printf(&quot;please input a path\n&quot;);
    fgets(name,N,stdin);//输入路径 
    int i=strlen(name);
    name[i-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(name);  
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_4">5.递归列出当前目录下所有文件，并按文件类型进行统计其个数</h4>

<p>相关知识：</p>

<ul>
<li>我们可以通过stat获取文件的类型和文件大小等信息。文件类型有：普通文件、目录文件、块特殊文件、字符特殊文件、FIFO、套接字和符号链接。</li>
<li>遇到目录文件时，递归调用函数自身，判断子目录下的文件是否是普通文件。</li>
<li>符号链接（软链接）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。</li>
<li>符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。某些需要特别处理符号链接的程序（如备份程序）可能会识别并直接对其进行操作。</li>
<li>一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。</li>
<li>S_ISREG (st_mode)     是否为普通文件</li>
<li>S_ISLNK (st_mode)     判断是否为符号连接</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
struct dirent *entry;
int a=0,b=0,c=0,d=0,e=0,f=0;
void fun(char *pathname){
    DIR *dp;
    char buf[N],path[N];int i;
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把当前目录的绝对地址保存到 buf 中
    getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        sprintf(path,&quot;%s/%s&quot;,buf,entry-&gt;d_name);//输出绝对路径
        printf(&quot;path file is %s\n&quot;,path);
        struct stat st;
        stat(path,&amp;st);
        if(S_ISDIR(st.st_mode))
            fun(path);
        else
            if(S_ISLNK(st.st_mode)) 
                a++;
            if(S_ISREG(st.st_mode))
                b++;
            if(S_ISDIR(st.st_mode)) 
                c++;
            if(S_ISCHR(st.st_mode)) 
                d++;
            if(S_ISBLK(st.st_mode)) 
                e++;
            if(S_ISSOCK(st.st_mode)) 
                f++;
    }
    closedir(dp);
}
int main(void){
    char name[N];
    printf(&quot;please input a path\n&quot;);
    fgets(name,N,stdin);//输入路径 
    int i=strlen(name);
    name[i-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(name);  
    printf(&quot;符号链接=%d\n&quot;,a);
    printf(&quot;一般文件=%d\n&quot;,b);
    printf(&quot;目录=%d\n&quot;,c);
    printf(&quot;字符装置文件=%d\n&quot;,d);
    printf(&quot;块设备文件=%d\n&quot;,e);
    printf(&quot;socket=%d\n&quot;,f);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_5">6.搜索指定目录下是否存在某个文件</h4>

<p>任务描述：</p>

<ul>
<li>递归搜索指定目录下是否存在某个文件，如果存在，则输出该文件的绝对路径，不存在，则输出提示</li>
<li>指定目录路径与待搜索文件名作为输入参数，打印输出搜索结果信息</li>
<li>如果判断文件是目录文件，则需要递归进行搜索</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
int flag=0;
void fun(char *pathname,char *filename){
    DIR *dp;
    struct dirent *entry;
    char buf[N],path[N];
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把当前目录的绝对地址保存到 buf 中
    getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        sprintf(path,&quot;%s/%s&quot;,buf,entry-&gt;d_name);//输出绝对路径
        struct stat st;
        if(stat(path,&amp;st)){ 
            printf(&quot;stat error\n&quot;);
            exit(1); 
        }
        if(S_ISDIR(st.st_mode))
            fun(path,filename);
        else{
            if(strcmp(entry-&gt;d_name,filename)==0{
                printf(&quot;%s\n&quot;,path);
                ++flag;
            }
        }
    }
    //if(flag==0)
        //printf(&quot;flag%d\n&quot;,flag);
    closedir(dp);
}
int main(void){
    char dir[N],name[N];
    printf(&quot;please input a pathname\n&quot;);
    fgets(dir,N,stdin);//输入路径
    printf(&quot;please input a filename\n&quot;);
    fgets(name,N,stdin);//输入文件名 
    int a=strlen(dir);
    dir[a-1]=&#39;\0&#39;;//将fgets最后的回车置零
    int b=strlen(name);
    name[b-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(dir,name); 
    if(flag==0)
        printf(&quot;file is not exist\n&quot;); 
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_6">7.列出指定目录在过去一小时内被修改的文件</h4>

<p>任务描述：</p>

<ul>
<li>输出指定目录下所有当前时刻起前一个小时内被修改的文件名及其对应的最后被修改时间</li>
</ul>

<p>相关知识：<br/>
在Linux下，一个文件也有三种时间，分别是：访问时间、修改时间、状态改动时间。<br/>
　　访问时间: 读一次这个文件的内容，这个时间就会更新。比如对这个文件运用 more、cat等命令。ls、stat命令都不会修改文件的访问时间。<br/>
　　修改时间: 修改时间是文件内容最后一次被修改时间。比如：vi后保存文件。ls -l列出的时间就是这个时间。<br/>
　　状态改动时间: 是该文件的i节点最后一次被修改的时间，通过chmod、chown命令修改一次文件属性，这个时间就会更新。</p>

<p>time_t time(time_t *t)：获得当前时间<br/>
　　返回从公元1970年1月1日的UTC时间从0时0分0秒算起到现在所经过的秒数。如果t并非空指针的话，此函数也会将返回值存到t指针所指的内存，成功返回秒数</p>

<p>通过stat结构体中的成员变量st_mtime可以获得文件的最后被修改时间</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;time.h&quot;
#include &quot;dirent.h&quot;
struct dirent *entry;
struct stat st;
int main(int argc,char *argv[]){
    DIR *dp=NULL;
    if(argc!=2){
        perror(&quot;argc error\n&quot;);
        exit(1);
    }
    if((dp=opendir(argv[1]))==NULL){
        perror(&quot;opendir error\n&quot;);
        exit(1);    
    }
    chdir(argv[1]);
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;
        if(stat(entry-&gt;d_name,&amp;st)!=0){
            perror(&quot;stat error\n&quot;);
            exit(1);
        }
        if(time(NULL)-st.st_mtime&lt;3600)
        printf(&quot;file is :%s\nthe last modify time is:%s\n&quot;,entry-&gt;d_name,ctime(&amp;st.st_mtime));
    }
    closedir(dp);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_7">8.列出指定目录下所有可被其他用户执行的文件</h4>

<p>相关知识：<br/>
使用st_mode &amp; S_IXOTH 可以获得文件的其他用户是否可执行的权限位，如果该位为1，则该文件可以被其他用户执行，否则不能被执行。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
struct stat st;
struct dirent *entry;
int main(int argc ,char *argv[]){
    char buf[1000];
    DIR *dirptr=NULL;
    if(argc!=2){
        perror(&quot;argc error\n&quot;);
        exit(1);
    }
    if((dirptr=opendir(argv[1]))==NULL){
        perror(&quot;stat error\n&quot;);
        exit(1);
    }else
        while(entry=readdir(dirptr)){
            if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
                continue;//如果输入的是相对路径，不处理
            sprintf(buf,&quot;%s/%s&quot;,argv[1],entry-&gt;d_name);//把传入的路径变为相对路径放入buf中
            if(stat(buf,&amp;st)!=0){
                perror(&quot;stat error\n&quot;);
                exit(1);
            }
            if(st.st_mode&amp;S_IXOTH)
                printf(&quot;%s can chmod \n&quot;,entry-&gt;d_name); 
        // else
        //   printf(&quot;error\n&quot;);
        }
    closedir(dirptr);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_8">9.列出指定目录下属于给定用户的所有文件</h4>

<p>相关知识：</p>

<ul>
<li>struct passwd * getpwnam(const char * name)：从密码文件中取得指定账号的数据</li>
</ul>

<p>　　　getpwnam()用来逐一搜索参数name 指定的账号名称，找到时便将该用户的数据以passwd结构返回。如果返回NULL 则表示已无数据，或有错误发生。<br/>
　　　passwd结构体定义如下：</p>

<blockquote>
<pre><code>struct passwd {
    char * pw_name; /* Username. */
    char * pw_passwd; /* Password. */
    __uid_t -pw_uid; /* User ID. */
    __gid_t -pw_gid; /* Group ID. */
    char * pw_gecos; /* Real name. */
    char * pw_dir; /* Home directory. -*/
    char * pw_shell; /* Shell program. */
};
</code></pre>
</blockquote>

<ul>
<li>根据获取的文件所有者的用户id和通过getpwnam获得的用户id进行比较，如果相同，则可判断该文件是要搜索的给定用户的文件。</li>
<li>st_mode中的st_uid就是文件所有者的用户id。</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;pwd.h&quot;
#include &quot;dirent.h&quot;
struct stat st;
struct passwd *pw;
int main(int argc,char *argv[]){
    char buf[1024];
    DIR *dp;
    struct dirent *entry;
    if(argc!=3){
        perror(&quot;argc error\n&quot;);
        exit(1);
    }
    pw=getpwnam(argv[2]);
    if(!pw){
        perror(&quot;getpwnam error\n&quot;);
        exit(1);
    }
    if((dp=opendir(argv[1]))==NULL){
        perror(&quot;opendir error\n&quot;);
        exit(1);
    }
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;
        sprintf(buf,&quot;%s/%s&quot;,argv[1],entry-&gt;d_name);
        if(stat(buf,&amp;st)!=0){
            perror(&quot;stat error\n&quot;);
            exit(1);
        }
        if(st.st_uid==pw-&gt;pw_uid)
            printf(&quot;user file is :%s\n&quot;,entry-&gt;d_name);      
    }
    closedir(dp);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_9">10.在指定目录下创建一个新目录</h4>

<p>任务描述：</p>

<ul>
<li>给出指定目录和要新建的子目录名做输入参数，打印信息表明是否创建成功</li>
<li>首先判断指定目录下是否已经存在要创建的目录，如果已存在，则不必再创建</li>
<li>通过比较指定目录下的所有目录的目录名是否与要创建的目录名称相同，来判断是否存在该目录</li>
</ul>

<p>相关知识：</p>

<ul>
<li>int mkdir(const char *pathname,mode_t mode)：创建目录</li>
</ul>

<p>　　　参数pathname是新创建目录的目录名，mode指定该目录的访问权限，这些位将受到文件创建方式屏蔽（umask）的修正。</p>

<p>　　　该函数创建一个名为pathname的空目录，此目录自动含有“.”和“..”2个登记项。这个新创建目录的用户ID被设置为调用进程的有效用户ID，其组则为父目录的组ID或者进程的有效组ID。<br/>
　　　若调用成功，mkdir将更新该目录的st_atime、st_ctime和st_mtime，同时更新其父目录的st_ctime和st_mtime，然后返回0。若调用失败，mkdir将返回-1.<br/>
　　　由pathname指定的新目录的父目录必须存在，并且调用进程必须具有该父目录的写权限以及pathname涉及的各个分路径目录的搜寻权限。</p>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
int flag=0;
void fun(char *pathname,char *filename){
    DIR *dp;
    struct dirent *entry;
    char buf[N];
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把当前目录的绝对地址保存到 buf 中
    getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        if(strcmp(entry-&gt;d_name,filename)==0){
            printf(&quot;file is exist,please try again\n&quot;);
            flag++;//如果文件存在 flag++
        }
    }
    closedir(dp);
}   
int main(void){
    char dir[N],name[N];
    printf(&quot;please input a pathname\n&quot;);
    fgets(dir,N,stdin);//输入路径
    printf(&quot;please input a filename\n&quot;);
    fgets(name,N,stdin);//输入文件名 
    int a=strlen(dir);
    dir[a-1]=&#39;\0&#39;;//将fgets最后的回车置零
    int b=strlen(name);
    name[b-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(dir,name);  
    if(flag==0)//如果文件不存在，子函数的flag没有++,仍然为0{
        mkdir(name,S_IRWXU);
        printf(&quot;create success\n&quot;);
    }
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_10">11.在指定目录下删除一个空目录</h4>

<p>任务描述：</p>

<ul>
<li>给出指定目录和要删除的子目录名做输入参数，打印信息表明是否删除成功</li>
<li>判断要删除的目录是否存在于指定目录下，如果存在，则再判断该目录是否为空</li>
</ul>

<p>相关知识：</p>

<ul>
<li>int rmdir(const char *pathname)：删除一个空目录</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
int flag=0;
void fun(char *pathname,char *dirname){
    DIR *dp1,*dp2;int a;
    struct dirent *entry;
    struct stat st;
    char buf[N];
    if((dp1=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把当前目录的绝对地址保存到 buf 中
    getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
    while(entry=readdir(dp1)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        if(stat(entry-&gt;d_name,&amp;st)!=0){
            perror(&quot;stat error\n&quot;);
            exit(1);
        }
        if(S_ISDIR(st.st_mode)){
            a=strcmp(entry-&gt;d_name,dirname);
            if(a==0){
                if((dp2=opendir(dirname))==NULL){
                    perror(&quot;open fail\n&quot;);
                    exit(1);
                }
                while(entry=readdir(dp2)){    
                    if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
                        continue;//如果输入的是相对路径，不处理
                    else{
                        flag=-1;
                        return ;
                    }
                }
                flag++;//如果目录存在 flag++
                closedir(dp2);
            }
        }
    // else  printf(&quot;your input is not a dir\n&quot;);
    }
    closedir(dp1);
}   
int main(void){
    char path[N],dir[N];
    printf(&quot;please input a pathname\n&quot;);
    fgets(path,N,stdin);//输入路径
    printf(&quot;please input a dirname\n&quot;);
    fgets(dir,N,stdin);//输入文件名 
    int a=strlen(path);
    path[a-1]=&#39;\0&#39;;//将fgets最后的回车置零
    int b=strlen(dir);
    dir[b-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(path,dir);  
    if(flag==-1)
        printf(&quot;please input a null dir\n&quot;);
    else 
        if(flag!=0){    //如果目录存在，子函数flag++,不为0
            rmdir(dir);
            printf(&quot;remove success\n&quot;);
        }else
            printf(&quot;dir is not exist\n&quot;); 
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_11">12.删除指定目录下的某个普通文件</h4>

<p>任务描述：</p>

<ul>
<li>先判断指定目录下是否存在该文件，如果不存在，则返回错误。如果存在，那么调用unlink函数或remove函数来删除</li>
<li>将文件的绝对路径和文件名作输入参数，打印信息表明是否删除成功</li>
</ul>

<p>相关知识：</p>

<ul>
<li>int unlink(const char * pathname)：删除文件　</li>
</ul>

<p>　　unlink()会删除参数pathname指定的文件。如果该文件名为最后连接点，但有其他进程打开了此文件，则在所有关于此文件的文件描述词皆关闭后才会删除。如果参数pathname为一符号连接，则此连接会被删除。　　　</p>

<ul>
<li>int remove(const char * pathname)：删除文件</li>
<li>删除参数pathname指定的文件。如果参数pathname为一文件，则调用unlink()处理，若参数pathname为一目录，则调用rmdir()来处理。</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
int flag=0;
void fun(char *pathname,char *filename){
    DIR *dp;
    struct dirent *entry;
    char buf[N];
    struct stat st;
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把当前目录的绝对地址保存到 buf 中
    getcwd(buf,N);//获得输入的目录并把当前目录的绝对地址保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)==0||strcmp(entry-&gt;d_name,&quot;..&quot;)==0)
            continue;//如果输入的是相对路径，不处理
        if(stat(entry-&gt;d_name,&amp;st)!=0){
            perror(&quot;stat error\n&quot;);
            exit(1);
        }
        if(S_ISDIR(st.st_mode)){
            if(strcmp(entry-&gt;d_name,filename)==0);{
                flag++;//如果目录存在 flag++
            }
        }
        if(strcmp(entry-&gt;d_name,filename)==0){
            flag++;//如果文件存在 flag++
        }
    }
    closedir(dp);
}   
int main(void){
    char name[N],path[N];int c;
    printf(&quot;please input a pathname\n&quot;);
    fgets(path,N,stdin);//输入路径
    printf(&quot;please input a filename\n&quot;);
    fgets(name,N,stdin);//输入文件名
    int a=strlen(path);
    path[a-1]=&#39;\0&#39;;//将fgets最后的回车置零
    int b=strlen(name);
    name[b-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(path,name);  
    if(flag!=0){        //如果文件存在,子函数flag++，flag不为0
        c=remove(name);
        if(c==0)
            printf(&quot;remove successful\n&quot;);
        else
            perror(&quot;please input file\n&quot;);
    }else
        printf(&quot;no find\n&quot;);
    return 0;
}
</code></pre>
</blockquote>

<h4 id="toc_12">13.列出指定目录下与正则表达式”abc*“匹配的所有文件</h4>

<p>任务描述：</p>

<ul>
<li>输入参数为指定目录路径和&quot;abc*&quot;，输出所有以abc开头的文件的绝对路径</li>
<li>可在task4的基础上完成，如果是子目录，再递归调用函数访问子目录下的所有文件</li>
</ul>

<p>相关知识：</p>

<ul>
<li>extern char *strstr(char *haystack,char *nedle)：从字符串haystack中寻找needle第一次出现的位置，但是该函数不比较结束符NULL</li>
<li>参数haystack是一个源字符串的指针，needle为一个目的字符串的指针</li>
</ul>

<p>main.c:</p>

<blockquote>
<pre><code>#include &quot;stdio.h&quot;
#include &quot;sys/types.h&quot;
#include &quot;sys/stat.h&quot;
#include &quot;unistd.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;dirent.h&quot;
#include &quot;string.h&quot;
#define N 1024
void fun(char *pathname,char *filename){
    DIR *dp;
    struct dirent *entry;
    char buf[N],path[N],str2[10]={0};
    if((dp=opendir(pathname))==NULL){
        perror(&quot;open fail\n&quot;);
        exit(1);
    }
    chdir(pathname);//把相对路径变为绝对路径
    getcwd(buf,N);//获得输入的路径并把当前路径的绝对路径保存到 buf 中
    while(entry=readdir(dp)){
        if(strcmp(entry-&gt;d_name,&quot;.&quot;)!=0&amp;&amp;strcmp(entry-&gt;d_name,&quot;..&quot;)!=0){//如果输入的不是相对路径
//          if(buf[strlen(buf)-1]==&#39;/&#39;)
                sprintf(path,&quot;%s/%s&quot;,buf,entry-&gt;d_name);//输出绝对路径
                struct stat st;//printf(&quot;%s\n&quot;,path);
                    if(stat(path,&amp;st)!=0){
                        perror(&quot;stat error\n&quot;);
                        exit(1);
                    }
                    if(S_ISDIR(st.st_mode))
                        fun(path,filename);
                    //else{
                strcpy(str2,entry-&gt;d_name);
                if(strstr(str2,filename))
                    printf(&quot;%s\n&quot;,path);
            // }
        }
    }
    chdir(&quot;..&quot;);
    closedir(dp);
}
int main(void){
    char path[N],name[N];
    printf(&quot;please input a path\n&quot;);
    fgets(path,N,stdin);//输入路径 
    int a=strlen(path);
    path[a-1]=&#39;\0&#39;;//将fgets最后的回车置零
    printf(&quot;please input a name\n&quot;);
    fgets(name,N,stdin);//输入路径 
    int b=strlen(name);
    name[b-1]=&#39;\0&#39;;//将fgets最后的回车置零
    fun(path,name);  
    return 0;
}
</code></pre>
</blockquote>


		</div>
	

 
	

 
	

 
	

 
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  </body>
</html>
